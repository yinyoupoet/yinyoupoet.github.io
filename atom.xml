<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yinyoupoet的博客</title>
  
  <subtitle>鲜衣怒马少年时</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yinyoupoet.github.io/"/>
  <updated>2019-12-02T14:03:42.000Z</updated>
  <id>https://yinyoupoet.github.io/</id>
  
  <author>
    <name>yinyoupoet</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://yinyoupoet.github.io/2019/11/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://yinyoupoet.github.io/2019/11/20/设计模式总结/</id>
    <published>2019-11-20T04:13:04.000Z</published>
    <updated>2019-12-02T14:03:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2><p>为避免软件危机，我们引入了软件工程学，而在软件工程学中，我们常面临的一个问题就是软件维护问题。软件维护涉及面很广，细化到代码编写方面，那便对代码规范有了要求，而设计模式则是一门面向编程规范的学问。在1995年，GoF（Gang of Four，四人组/四人帮）出版了《设计模式：可复用面向对象软件的基础》一书，提出了23种设计模式，而这也成了如今非常经典的软件设计与程序编写规范。在最近几年中，笔者已学过四遍了，算不上太多心得体会，但也多少有些收获，因此将其记录下来以备查阅。本文将对设计模式进行一个精要的讲解，所涉及内容不会太详细，小白慎入。（注：本文中部分文字和图片来自网络，参考资料统一列于文章最后，侵删）</p><h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2><p>要学习设计模式，首先要会一门程序设计语言，以面向对象者入手为佳，本文以java来展开。其次，要会UML的类图，关于其网上资料很多，在此不做赘述。第三点，就是一些颇为经典的软件设计原则，这里将其列出并作简单介绍：</p><ul><li>单一职责原则：一个类只干一件事——低耦合，高内聚</li><li>开闭原则：对扩展开放，对修改关闭</li><li>里氏代换原则：能接受基类的地方必能接受子类</li><li>依赖倒转原则：依赖于抽象而非具体类——针对抽象编程</li><li>接口隔离原则：用多个专门的接口取代单个统一的接口——降低耦合</li><li>合成复用原则：多用组合/聚合，少用继承</li><li>迪米特法则：若两个类不彼此直接通信，则此二者不能直接发生作用，需引入第三个类</li></ul><h2 id="设计模式总体介绍"><a class="markdownIt-Anchor" href="#设计模式总体介绍"></a> 设计模式总体介绍</h2><p>如下图所示，设计模式一共可分为三类模式，分别是创建型模式、结构型模式、行为型模式。</p><table><thead><tr><th>范围目的</th><th><strong>创建型模式</strong></th><th><strong>结构型模式</strong></th><th><strong>行为型模式</strong></th></tr></thead><tbody><tr><td><strong>类模式</strong></td><td>工厂方法模式</td><td>（类）适配器模式</td><td>解释器模式  <br>模板方法模式</td></tr><tr><td><strong>对象模式</strong></td><td>抽象工厂模式  <br>建造者模式  <br>原型模式 <br> 单例模式</td><td>（对象）适配器模式  <br>桥接模式  <br>组合模式 <br> 装饰模式  <br>外观模式  <br>享元模式 <br> 代理模式</td><td>职责链模式  <br>命令模式 <br> 迭代器模式 <br> 中介者模式 <br> 备忘录模式 <br> 观察者模式  <br>状态模式  <br>策略模式  <br>访问者模式</td></tr></tbody></table><p>各类模式的关系如下图所示：</p><p><img alt="模式关系图" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120190446121.png" class="lozad"></p><h2 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h2><h3 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h3><blockquote><p><strong>Factory Method Pattern</strong>: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p></blockquote><p><img alt="工厂方法模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120220805432.png" class="lozad"></p><p>将工厂和产品都抽象化了，但是具体的生产仍是由一个具体工厂生产一个具体产品。但是需要注意的是，一个具体工厂只生产一个具体产品，即一个工厂类只负责生产一类产品对象，这虽然符合了开闭原则，但是每增加一个产品时都需要新创建一个具体产品类和一个具体工厂类。</p><h3 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h3><p>工厂模式每个具体工厂只能生产一类对象，这在需要新增加产品类时会比较麻烦，因此抽象工厂模式中一个工厂类可以创建多类对象。</p><blockquote><p><strong>Abstract Factory Pattern</strong>: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p></blockquote><p><img alt="抽象工厂模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120221832027.png" class="lozad"></p><p>譬如说某个具体工厂为海尔工厂，则其既可以生产海尔电视机，也可以生产海尔冰箱。当需要生产TCL的电视机和电冰箱时，只需添加对应的具体工厂和具体产品即可，但是如果需要添加一个新的产品，比如说海尔需要生产手机了，那么这时还得修改其对应的具体工厂，因此可以看出其对于开闭原则也不能很好地遵循。</p><h3 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h3><p>建造者模式讲究一步一步创建一个产品，创建的步骤是相同的，但是创建的产品的类型却可以不同。</p><blockquote><p><strong>Builder Pattern</strong>: Separate the construction of a complex object from its representation so that the same construction process can create different representations.</p></blockquote><p><img alt="建造者模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120223344579.png" class="lozad"></p><p>客户类只需调用构造者类的<code>getResult</code>方法即可，根据具体类中每个部分的构建方式不同，<code>getResult</code>返回的内容也不同，譬如肯德基的套餐，不同的套餐都有食物和饮料，但每个套餐提供的食物和饮料的种类却是不同的。</p><p>增加新的具体构建者不需要修改现有代码，符合开闭原则。但是如果产品的内部变化较大，则会需要很多个具体构建者，会使得类的结构比较臃肿。</p><h3 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h3><p>原型模式说明白点就是对象的自我拷贝，返回一个和自己一模一样的对象，只需根据需求来设置深拷贝和浅拷贝即可。</p><blockquote><p><strong>Prototype Pattern</strong>: Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.</p></blockquote><p><img alt="原型模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120224228849.png" class="lozad"></p><h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3><p>单例模式即为让类只能产生一个对象，无论谁来访问都只能访问到同一个对象。其原理就是将构造函数设置为私有函数，由一个公有静态接口来返回类的唯一实例。</p><blockquote><p><strong>Singleton Pattern</strong>: Ensure a class has only one instance and provide a global point of access to it.</p></blockquote><p><img alt="单例模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120224444809.png" class="lozad"></p><p>单例模式分为饿汉式和懒汉式，饿汉式即在类加载时就创建了这个类的唯一实例，而懒汉式则在外部第一次获取该类的对象时才创建对象，上图所示即为懒汉式。</p><p>使用单例模式的思路可以设计<em>有限多例模式</em>，在此不做赘述。</p><h2 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式"></a> 结构型模式</h2><p>结构型模式讨论的是如何将类或对象结合在一起形成更大的结构，可以相应地分为类结构型模式和对象结构型模式。</p><h3 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h3><p>顾名思义，一般电脑充电器都会自带一个电源适配器，以将220V的电压适配到电脑电源所能接受的电压。适配器模式亦然，一个现有类已经实现了一些能满足客户端所要求的功能，但提供的接口不符合客户的需求，比如接口名和客户要求的接口名不同，因此这时可以设计一个适配器程序，由客户端只需调用适配器中符合客户要求的接口，而在适配器内部则代替客户端去调用那个现有类的函数。</p><blockquote><p><strong>Adapter Pattern</strong>: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</p></blockquote><p><img alt="类适配器" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120225426230.png" class="lozad"></p><p><img alt="对象适配器" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120225441222.png" class="lozad"></p><p>适配器模式使得目标类与客户类解耦，使得这个调用过程成了透明的过程，也增加了程序的可扩展性与可维护性，即便修改了目标类的实现代码，或者干脆换了一个类作为目标类，也只需要修改适配器类的内部代码即可，而不需对客户类进行任何修改。但是往往一个适配器类只能为一个客户端类服务，这也在一定程度上会使得代码比较臃肿。</p><h3 id="桥接模式"><a class="markdownIt-Anchor" href="#桥接模式"></a> 桥接模式</h3><p>桥接模式用于一个物体有两个或更多不同类型的属性的时候，用于化全连接的乘法为两两组合的加法。听起来很抽象，那就举个栗子。比如要创建一个图形，形状上有圆形、矩形、三角形，颜色上有红色、绿色、蓝色，因此如果为每一种形状都提供一个单独的颜色的版本的话，就需要9种不同的类，而如果使用桥接模式，则只需要单独定义3种图形和3种颜色，即一共6种，这在更复杂的系统中能显著减少类的数量。</p><p>其设计思想如下图，上面为采用全连接的思想，而下面则采用的是桥接模式的思想。</p><p><img alt="桥接模式设计思想" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124155424510.png" class="lozad"></p><blockquote><p><strong>Bridge Pattern</strong>: Decouple an abstraction from its implementation so that the two can vary independently.</p></blockquote><p>桥接模式的类图如下：</p><p><img alt="桥接模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124160018001.png" class="lozad"></p><p>桥接模式提高了系统的可扩展性，扩展任何一个维度都不需要修改原有的系统，符合开闭原则，且其分离了抽象接口与其具体实现，使得具体类的实现对用户透明，但是其会增加系统的理解与设计难度，且要求抽象出系统中某两个单独变化的维度，因此其使用具有一定的局限性。</p><h3 id="组合模式"><a class="markdownIt-Anchor" href="#组合模式"></a> 组合模式</h3><p>组合模式包含两类对象，分别是容器对象和叶子对象，而其目的就是可以透明地处理容器对象和叶子对象。比如对于文件和文件夹的遍历等。</p><blockquote><p><strong>Composite Pattern</strong>: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p></blockquote><p><img alt="组合模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124164159949.png" class="lozad"></p><p>组合模式比较简单，就不多解释了，它分为透明组合模式和安全组合模式，透明组合模式是在抽象构建中声明所有要使用的操作，而安全组合模式中抽象构建中仅声明公有操作。</p><h3 id="装饰模式"><a class="markdownIt-Anchor" href="#装饰模式"></a> 装饰模式</h3><p>为一个类或对象增加行为，常采用的有继承和关联两种方法，然而继承的话，对现有类的扩充不能动态进行控制，而关联就不同，可以设计一个装饰类来按需求动态地扩充被嵌入对象的行为，因此装饰模式采用的是关联机制来对类进行扩充。</p><blockquote><p><strong>Decorator Pattern</strong>: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p></blockquote><p><img alt="装饰模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124171952767.png" class="lozad"></p><p>需要注意的是，装饰类的接口与被装饰类的接口要保持一致，这样客户端在使用的时候才能在不修改接口的情况下调用装饰类的实现。装饰模式比使用继承更加灵活，而且也符合开闭原则、合成复用原则等。抽象模式可以分为透明模式和半透明模式，透明模式中用户完全针对抽象编程，这点作简单了解即可。</p><h3 id="外观模式"><a class="markdownIt-Anchor" href="#外观模式"></a> 外观模式</h3><p>外观模式为每一个子系统提供了一个对外通信的统一的接口（外观类），客户类只需知道这个接口即可，而具体的复杂的这个子系统的实现过程则由外观类去实现。其能显著降低系统复杂度，提高客户端使用的便捷性。</p><blockquote><p><strong>Facade Pattern</strong>: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p></blockquote><p><img alt="外观模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124174332372.png" class="lozad"></p><p>用外观模式举个例子，即定义一个总开关作为外观类，其提供打开和关闭两种操作，而打开或关闭开关时，其自动打开或关闭了电灯、冰箱、电视等一系列的开关，而作为客户而言，只需打开这一个开关，子系统（外观类）就能为客户做一系列复杂的操作，而这些操作对客户而言都是透明的。但是当新增子系统时，可能需要修改外观类或客户端的源代码，这违背了开闭原则。需要注意的是，外观类的用意是为子系统提供一个集中化和简化的管理接口，因此不要在外观类中为子系统添加新的行为，那是装饰模式才干的事。</p><h3 id="享元模式"><a class="markdownIt-Anchor" href="#享元模式"></a> 享元模式</h3><p>享元模式很好理解，它的目的就是实现对象的共享。试想在开发中，加入需要经常是用到某一个字符串，比如<code>s='abc'</code>，那么就可以将这个对象丢入对象池中，每次访问时都从对象池中将其取出即可，而不用在每次使用前都new一次，这样会造成内存空间的浪费。</p><p>根据对象信息的性质不同，可以将信息分为两类，一个为内部状态，这个是固定在享元对象中不会变的信息，即可以共享的信息，而外部状态则是会随着环境改变而改变的信息，即不可共享的部分。</p><blockquote><p><strong>Flyweight Pattern</strong>: Use sharing to support large numbers of fine-grained objects efficiently.</p></blockquote><p><img alt="享元模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124210912346.png" class="lozad"></p><p>享元模式支持大量细粒度对象的复用，能极大减小内存中对象的数量，当系统中有大量对象且这些对象消耗大量内存、且这些对象的状态大部分可以外部化时，享元模式能起到很显著的作用。</p><h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3><p>当客户端与目标对象之间不能直接通信时，往往采用代理模式，定义一个代理对象作为中介，根据实际需求为去掉一些客户不能看到的内容或者添加一些用户需要的额外服务，也包括数据加密等等。</p><blockquote><p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.</p></blockquote><p><img alt="代理模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124211448973.png" class="lozad"></p><p>代理模式能协调客户端和目标程序之间的通信，并对其数据进行加工处理，在一定程度上降低了系统的耦合度，但是因为添加了一个代理，因此代理在进行数据处理时往往会耗费一些额外的时间，而比如远程代理，更是会带来一些额外的通信时延，且有的代理模式的实现也较为复杂。</p><h2 id="行为型模式"><a class="markdownIt-Anchor" href="#行为型模式"></a> 行为型模式</h2><p>行为型模式控制类和对象之间相互协作的任务分配和流程控制，它分为对象行为型模式和类行为型模式，而通过合成复用原则可知，对象行为型模式比类行为型模式更加灵活，因此对象行为型模式使用范围往往更广。</p><h3 id="职责链模式"><a class="markdownIt-Anchor" href="#职责链模式"></a> 职责链模式</h3><p>该模式思路为将请求发送者与接收者分离开来，即请求发送者不能直接接触到最终的接收者，所有发送者的请求都只能被送到一个职责链的开始节点，而职责链中每个节点都具有接收请求和处理请求的能力，但是每个节点能处理的请求都是有限制的，比如请假系统，每一级领导最高职能批多少天的假，超出他的审批权限则需要他将这个请求汇报给上级处理，这样一条请求链就是职责链。</p><blockquote><p><strong>Chain of Responsibility Pattern</strong>: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p></blockquote><p><img alt="职责链模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202201658934.png" class="lozad"></p><p>职责链模式的使用能显著降低系统耦合度，简化对象间的连接复杂度，也使得请求的处理相对于客户而言是透明的，增加了稳定性和灵活性。但是不能保证请求一定被处理，且由于请求需要一层层传递下去，可能会对系统性能产生影响。职责链模式分为纯的和不纯的职责链模式。纯的职责链模式要求每一个职责链节点只能选择处理或者将请求传递给下一个节点，不允许在进行了部分处理后又交给下一个节点处理，且纯的职责链节点必须能处理所有可能的请求，而在不纯的职责链中，允许一个请求最终不被任何接收者处理。</p><h3 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h3><p>命令模式将请求的发送与处理完全解耦，请求发送者只需要知道发送指令的接口即可，并不需要知道是谁在什么时候执行了具体什么操作。</p><blockquote><p><strong>Command Pattern</strong>: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p></blockquote><p><img alt="命令模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202202842015.png" class="lozad"></p><p>命令模式中调用者只需调用Command抽象类中的执行操作函数，而具体操作则由具体命令类来执行。它可以降低系统耦合度，也提高了系统可扩充性，易于设计组合命令，但是也可能会造成系统中具体命令类过多的情况。使用命令模式可以实现撤销功能，即在具体命令类中记录上一次的操作，从而实现撤销。</p><h3 id="解释器模式"><a class="markdownIt-Anchor" href="#解释器模式"></a> 解释器模式</h3><p>解释器模式平日里用的机会不多，它是设计了一个句子的解释器，学过编译原理的朋友们可能对词法分析、语法分析等概念还有概念，而解释器模式则设计了一个解释器去解释一个特定的句子，比如简单的四则运算，难一点的自定义代码解析等。</p><blockquote><p><strong>Interpreter Pattern</strong>: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</p></blockquote><p><img alt="解释器模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202204243789.png" class="lozad"></p><p>使用解释器可以很容易地改变和扩充文法，且易于增加新的解释表达式的方法，但是使用场景实在少见，执行效率较低，无特殊需求的话仅做了解即可。</p><h3 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h3><p>迭代器模式就是为一个集合定义一个遍历访问的机制，如java的List、Set等的遍历，不过这些遍历都是系统一经定义好了的，我们也可以对自己设计的集合定义遍历的方式，也可以对已有的集合定义我们所需的迭代方式。</p><blockquote><p><strong>Iterator Pattern</strong>: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p></blockquote><p><img alt="迭代器模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202204649120.png" class="lozad"></p><p>迭代器模式支持对同一个集合定义不同的遍历方式，且新增便利方式或聚合类都不需要修改其他代码，符合开闭原则。但是新增聚合类则意味着要新增迭代器类，这会造成类的个数的成对增加，增加了系统复杂度。该模式使得对无需了解聚合对象的内部表示即可遍历一个聚合对象，只需一个统一的接口即可。</p><h3 id="中介者模式"><a class="markdownIt-Anchor" href="#中介者模式"></a> 中介者模式</h3><p>中介者模式的目的就是设计一个单独的中介对象来管理所有其他对象之间的相互做作用，而非让对象间自行组织和作用，它减少了对象间两两之间的引用关系，使系统成为了一个松耦合的系统。如果让对象两两间直接通信或作用，则一个对象发送变化时可能需要引起另一个对象行为的改变，这会造成系统非常复杂且难以维护。举个具体的例子，比如工厂中设备A、B、C的启动过程构成一个循环，即当启动A时A会自动启动B，而后B会自动启动C，而当启动B时B会自动启动C，而后C自动启动A，等等这样构成一个循环，本来是没问题，但是如果B设备坏了，则启动A后设备C也不会自动启动，而如果采用一个中介者，由中介者对其他设备进行启动，就没有这种问题了。</p><blockquote><p><strong>Mediator Pattern</strong>: Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</p></blockquote><p><img alt="中介者模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202210821758.png" class="lozad"></p><p>中介者模式简化了对象间的直接交互，但是容易造成中介者类十分复杂，难以维护。</p><h3 id="备忘录模式"><a class="markdownIt-Anchor" href="#备忘录模式"></a> 备忘录模式</h3><p>备忘录模式就相当于github上的一次提交，每提交一次都会保留一份备份。而备忘录模式也是在每一次执行备份操作的时候，保存一个对象的内部状态，并提供恢复机制，将对象还原到其之前保存的状态。</p><blockquote><p><strong>Memento Pattern</strong>: Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</p></blockquote><p><img alt="备忘录模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202211231328.png" class="lozad"></p><p>备忘录模式提供了一种备份与恢复机制，但是如果备份较频繁，则会加大系统资源的消耗，它也可以用作实现撤销操作，且其功能相较命令模式而言要强大得多，也更易于实现。</p><h3 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h3><p>该模式又称发布-订阅模式，其目的是当一个对象（被观察者）状态发送改变时，通知其他依赖于它的对象（观察者）它的状态的改变，并视情况对观察者的状态进行调整。</p><blockquote><p><strong>Observer Pattern</strong>: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p></blockquote><p><img alt="观察者模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202213536454.png" class="lozad"></p><p>该模式可以实现表示层和数据层数据的分离，当表示层数据发生变化时，这个变化可以自动传播到数据层中，如果用在注册表单中，则体现在每修改一次用户名，则可以自动异步在后台判断该用户名是否和已存用户名重名。同时一个对象可以有多个观察者，这意味着这个对象的状态发生改变后需要通知所有其他观察者，这对系统性能有点影响，且如果观察关系较为复杂，则可能存在循环观察，这点需要引起重视。</p><h3 id="状态模式"><a class="markdownIt-Anchor" href="#状态模式"></a> 状态模式</h3><p>状态模式规定一个对象在其内部状态不同的时候，同样的操作会执行不同的行为。比如同一个函数中，会判断属于什么状态再去执行相应的功能。</p><blockquote><p><strong>State Pattern</strong>: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p></blockquote><p><img alt="状态模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202214255779.png" class="lozad"></p><p>从类图可以看出，每一个状态对应一个具体类，而具体操作由具体状态类来定义，这就将状态和操作从原始类中抽离了出来，这意味着新增一个具体状态时不需要修改原始代码，似乎符合开闭原则，但是它对开闭原则的支持并不太好，但是对于能够实现状态转换的类而言，每新增一个状态都需要修改类中进行状态转换的相关代码。</p><h3 id="策略模式"><a class="markdownIt-Anchor" href="#策略模式"></a> 策略模式</h3><p>策略模式指在实现某一个既定目标的时候，有多个不同的可选方法，比如排序算法，可以视情况动态选择快排、归并等算法，而不需要硬编码在原始程序中。</p><blockquote><p>​      Strategy Pattern: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p><img alt="策略模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202214845730.png" class="lozad"></p><p>策略模式很好地支持了开闭原则，但是它要求客户端知道所有的策略类，且策略模式会需要生成很多个策略类，可以使用享元模式在一定程度上减少策略类的个数。</p><h3 id="模板方法模式"><a class="markdownIt-Anchor" href="#模板方法模式"></a> 模板方法模式</h3><p>该方法的目的是基于继承的思路来增加代码的复用。它定义了一个抽象父类，并实现了部分公有方法，而另一些方法则仅定义了接口，留给子类去实现。</p><blockquote><p><strong>Template Method Pattern</strong>: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p></blockquote><p><img alt="模板方法模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202215333515.png" class="lozad"></p><p>模板方法模式能很大程度上提高代码的复用率，但是对于每个不同的实现都需要单独定义一个子类，这会使得子类数量很多，难以维护。</p><h3 id="访问者模式"><a class="markdownIt-Anchor" href="#访问者模式"></a> 访问者模式</h3><p>该模式是针对数据或对象的访问而言，不同的用户对同一个对象或数据进行访问时往往有不同的访问权限，或会采取不同的操作手段，而访问者模式则是用来对访问的一个控制，它能使得在不修改原始代码的前提下新增数据访问或操作的方式。</p><blockquote><p><strong>Visitor Pattern</strong>: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p></blockquote><p><img alt="访问者模式" data-src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202220032255.png" class="lozad"></p><p>该模式使得新增访问操作变得很容易，所有元素相关操作都集中到了访问对象中。但是这也使得新增数据项就很困难，新增数据项需要修改所有的访问对象的代码，使得维护相当困难。</p><hr><p>以上就是23种设计模式的简单总结，若有尚不清晰之处，日后慢慢补充。</p><hr><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ul><li><a href="https://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">设计模式总结</a></li><li><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">Java设计模式：23种设计模式全面解析（超级详细）</a></li><li><a href="https://blog.csdn.net/qq_41997479/article/details/86619024" target="_blank" rel="noopener">软件体系结构与设计模式——课程总体介绍（01-03）</a></li><li><a href="https://www.cnblogs.com/adamjwh/p/9070107.html" target="_blank" rel="noopener">简说设计模式——享元模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      精要论述23种设计模式，并进行融会贯通。
    
    </summary>
    
      <category term="软件开发" scheme="https://yinyoupoet.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="设计模式" scheme="https://yinyoupoet.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Wireless Network Evolution - 6G &amp; AI</title>
    <link href="https://yinyoupoet.github.io/2019/11/05/Wireless-Network-Evolution-6G-AI/"/>
    <id>https://yinyoupoet.github.io/2019/11/05/Wireless-Network-Evolution-6G-AI/</id>
    <published>2019-11-05T07:18:17.000Z</published>
    <updated>2019-11-05T13:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h2><p>6G is gonna be the main melody in 2030s while 5G is being deployed around the world, and is gonna be one of the main supports of the fourth industrial revolution. Undoubtedly Artificial Intelligence will be the key role in the upcoming industrial revolution, so many scientists think that the next generation of networks may not be the simple connection of things, but the connection of intelligence.</p><p>As we can see 5G, whose main features include eMBB (enhanced mobile broadband), uRLLC (ultra-reliable and low-latency communications) and mMTC (massive machine-type communication), does a very little of things to integrate AI into its network architecture, most of the work they did are about how to achieve super low latency and high bandwidth. Nevertheless, in 6G, we may have much higher requirements with more stringent requirements. The typical features are as follows<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>:</p><ul><li>Very high data rates, up to 1 Tbps;</li><li>Very high energy efficiency, with the ability to support battery-free IoT devices;</li><li>Trusted global connectivity;</li><li>Massive low-latency control (less than 1 msec end-to-end latency);</li><li>Very broad frequency bands (e.g., 73GHz-140GHz and 1THz-3THz);</li><li>Ubiquitous always-on broadband global network coverage by integrating terrestrial wireless with satellite systems;</li><li>Connected intelligence with machine learning capability and AI networking hierarchy.</li></ul><p>What 6G is gonna achieve based on 5G are described below<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>.</p><p><strong>Computation Oriented Communications (COC):</strong> New smart devices call for distributed and in-network computation to enable the key functionalities of AI-empowered 6G, such as federated learning and edge intelligence. Instead of targeting classical quality of service (QoS) provisioning, CoC will flexibly choose an operating point in the rate-latency-reliability space depending on the availability of various communications resources to achieve a certain computational accuracy.</p><p><strong>Contextually Agile eMBB Communications (CAeC):</strong> The provision of 6G eMBB services is expected to be more agile and adaptive to the network context, including communication network context such as link congestion and network topology; physical environment context such as surrounding location and mobility; and social network context such as social neighborhood and sentiments.</p><p><strong>Event Defined uRLLC (EDuRLLC):</strong> In contrast to the 5G uRLLC application scenario (e.g., virtual reality and industrial automation) where redundant resources are in place to offset many uncertainties, 6G will need to support uRLLC in extreme or emergency events with spatially and temporally changing device densities, traffic patterns, and spectrum and infrastructure availability.</p><p>6G is gonna be an intelligent information system whose roadmap is as followed (the image comes from<sup class="footnote-ref"><a href="#fn1" id="fnref1:2">[1:2]</a></sup>).</p><p><img alt="The roadmap of 6G" data-src="/images/Wireless-Network-Evolution-6G-AI/image-20191105160805762.png" class="lozad"></p><p>The potential network architecture for 6G is shown below (the image comes from<sup class="footnote-ref"><a href="#fn1" id="fnref1:3">[1:3]</a></sup>).</p><p><img alt="The architecture of 6G" data-src="/images/Wireless-Network-Evolution-6G-AI/image-20191105161131754.png" class="lozad"></p><h2 id="what-can-ai-empowered-6g-do"><a class="markdownIt-Anchor" href="#what-can-ai-empowered-6g-do"></a> What can AI empowered 6G do?</h2><p>6G will be substantially different from the previous generations as it will be characterized by a high degree of heterogeneity in multiple aspects such as network infrastructures, radio access technologies, RF devices, computing and storage resources, application types, etc. And it’s obviously that the volume and variety of data in the network will grow significantly which indicates AI is demanded as an indispensable tool to facilitate intelligent learning, reasoning, and decision making to achieve data-driven network planning and operation to realize real-time additivity to dynamic network environments<sup class="footnote-ref"><a href="#fn1" id="fnref1:4">[1:4]</a></sup>.</p><p>AI can help 6G to make advances in many fields, such as big data analytics in 6G, closed-loop optimization, and wireless communication, etc. In this article, we only focus on the intelligent wireless communication.</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Letaief K B , Chen W , Shi Y , et al. The Roadmap to 6G – AI Empowered Wireless Networks[J]. IEEE Communications Magazine, 2019. <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a> <a href="#fnref1:2" class="footnote-backref">↩︎</a> <a href="#fnref1:3" class="footnote-backref">↩︎</a> <a href="#fnref1:4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      What will 6G be? What research shall we going on?
    
    </summary>
    
      <category term="Networks" scheme="https://yinyoupoet.github.io/categories/Networks/"/>
    
    
      <category term="AI" scheme="https://yinyoupoet.github.io/tags/AI/"/>
    
      <category term="6G" scheme="https://yinyoupoet.github.io/tags/6G/"/>
    
  </entry>
  
  <entry>
    <title>5G与人工智能的应用场景分析与探索</title>
    <link href="https://yinyoupoet.github.io/2019/10/06/5G%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E4%B8%8E%E6%8E%A2%E7%B4%A2/"/>
    <id>https://yinyoupoet.github.io/2019/10/06/5G与人工智能的应用场景分析与探索/</id>
    <published>2019-10-06T11:01:00.000Z</published>
    <updated>2019-10-06T13:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>5G包含三个方面的场景，分别为：</p><ul><li>eMBB：增强移动宽带，针对大流量移动宽带业务</li><li>mMTC：大连接物联网，针对大规模物联网业务</li><li>URLLC：超高可靠超低时延通信</li></ul><p>而在5G即将到来之际，其与AI的相关应用场景的探索也正在紧锣密鼓地进行着，本文中我将根据一些资料的介绍，并结合自己的理解，对其进行总结与探索。</p><hr><p>目前AI技术的发展已经渐渐开始放缓，而AI如何落地、如何真正发挥最大作用以方便人们生活，这才是目前政府、企业和寻常百姓所最关心的问题。站在5G的浪潮上，AI自然而然地被期望与5G共同发展。相比于从前的网络，5G带来了更大的带宽、更大规模的连接和更低时延高可靠的服务，因此关于AI赋能5G的应用，或将需要从这些方面开始入手。</p><p>从5G网络特点来看，其频率主要分成FR1频段（<em>450MHz——6GHz</em>）和FR2频段（<em>24.25GHz——52.6GHz</em>），而FR2频段的频率远高于当前所用网络的频率，而频率变高则意味着波长变短，因此其被称之为毫米波<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。毫米波带宽更大、数据速率更高，但是也更易损耗、覆盖范围也更小，因此相对于传统4G网络的基站而言，5G需要更多的微基站，或可称为超密集组网（Ultra Dense Network）。而为了应对毫米波易受干扰（噪声）的问题，5G将采用大规模天线的架构，以降低噪声干扰所造成的影响。针对不同的应用场景，5G需要定义不同的网络切片，而对于一些对时延要求较高的应用，往往需要与移动边缘计算（MEC）协同工作。</p><p><img alt="5G几个应用场景 (引用自[2])" data-src="/images/5G%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E4%B8%8E%E6%8E%A2%E7%B4%A2/1570363366954.png" class="lozad"></p><p>AI方面，自从算力的价格下跌、以及深度学习的出现，人们已经拥有快速对超大规模特征进行建模的能力。而在5G的加持下，新一代人工智能即将到来。</p><p>AI能干的事情很多，但是在5G的加持下其必将干的更好，很多从前做不到的事情或将成为现实。其部分应用场景列举如下：</p><ul><li>智慧城市：依托5G和AI，改善社会治理、改善民生、升级产业、环境监督等；</li><li>智能交通：对城区交通情况进行建模，并通过VANET网络向司机或车载智能设备提出建议，以供更好提前规划交通出行策略，达到避免拥堵、避免碰撞，甚而达到自动驾驶；</li><li>智能环保：智能预测与监督、预警。</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/wangyongtao1240/article/details/80412092" target="_blank" rel="noopener">为什么5G要使用毫米波？</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>王喜⽂.5G为人工智能和智能制造赋能[EB/OL].2019-7/2019-10-06 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;5G包含三个方面的场景，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eMBB：增强移动宽带，针对大流量移动宽带业务&lt;/li&gt;
&lt;li&gt;mMTC：大连接物联网，针对大规模物联网业务&lt;/li&gt;
&lt;li&gt;URLLC：超高可靠超低时延通信&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而在5G即将到来之际，
      
    
    </summary>
    
      <category term="5G" scheme="https://yinyoupoet.github.io/categories/5G/"/>
    
    
      <category term="5G" scheme="https://yinyoupoet.github.io/tags/5G/"/>
    
      <category term="AI" scheme="https://yinyoupoet.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>从文献综述看AI与车联网的融合发展【附相关论文】</title>
    <link href="https://yinyoupoet.github.io/2019/10/05/%E4%BB%8E%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E7%9C%8BAI%E4%B8%8E%E8%BD%A6%E8%81%94%E7%BD%91%E7%9A%84%E8%9E%8D%E5%90%88%E5%8F%91%E5%B1%95%E3%80%90%E9%99%84%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E3%80%91/"/>
    <id>https://yinyoupoet.github.io/2019/10/05/从文献综述看AI与车联网的融合发展【附相关论文】/</id>
    <published>2019-10-05T06:01:27.000Z</published>
    <updated>2019-10-07T08:10:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于AI与车联网的融合发展，我将在本文中对几篇文献综述中所提到的信息进行总结，并将在最后进行整体归纳。在此向文献综述的作者们致以崇高的谢意。</p><h1 id="popular-content-distribution-in-public-transportation-using-artificial-intelligence-techniques"><a class="markdownIt-Anchor" href="#popular-content-distribution-in-public-transportation-using-artificial-intelligence-techniques"></a> <a href="https://uwspace.uwaterloo.ca/handle/10012/14908" target="_blank" rel="noopener">Popular Content Distribution in Public Transportation Using Artificial Intelligence Techniques</a> ——2019.1.8</h1><p>V2X有三大应用场景：traffic efficiency, road safety, energy efficiency</p><table><thead><tr><th>标题</th><th>总结</th></tr></thead><tbody><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/8345672" target="_blank" rel="noopener">Machine Learning for Vehicular Networks: Recent Advances and Application Examples</a><br><strong>IEEE Vehicular Technology Magazine （SCI 2区）- 2018</strong></td><td>【文献综述】车联网研究现状及应用场景。【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/document/6823640" target="_blank" rel="noopener">Connected Vehicles: Solutions and Challenges</a><br><strong>IEEE Internet of Things Journal （SCI 1区）- 2014</strong></td><td>The challenges and various solutions to connected vehicles【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/document/8425297" target="_blank" rel="noopener">Vehicle Safety Improvement through Deep Learning and Mobile Sensing</a><br><strong>IEEE Network（SCI 1区）- 2018</strong></td><td>identifies two main challenges in this context:1) driving safety analysis, and 2) road safety analysis. They proposed a new deep learning framework known as DeepRSI, to conduct real-time predictions of the road safety【已下载】</td></tr><tr><td><a href="https://link.springer.com/article/10.1007%2Fs11042-017-5054-6" target="_blank" rel="noopener">Driver information system: a combination of augmented reality, deep learning and vehicular Ad-hoc networks</a><br><strong>MULTIMEDIA TOOLS AND APPLICATIONS （SCI 3-4区）- 2017.8.3</strong></td><td>applied deep learning to improve vehicle safety and comfort by performing human factors assessment and displaying the surrounding information to the drivers【已下载】</td></tr><tr><td>A linear model predictive planning approach for overtaking manoeuvres under possible collision circum- stances<br><strong>2018 IEEE Intelligent Vehicles Symposium (IV) （顶会）</strong></td><td>【已下载】</td></tr><tr><td>Vehicle trajectory prediction with Gaussian process regression in connected vehicle environment<br><strong>2018 IEEE Intelligent Vehicles Symposium (IV) （顶会）</strong></td><td>【已下载】</td></tr><tr><td>Cooperative collision avoidance by sharing vehicular subsystem data<br><strong>2018 IEEE Intelligent Vehicles Symposium (IV) （顶会）</strong></td><td>【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/document/7391019?arnumber=7391019&amp;tag=1" target="_blank" rel="noopener">LTE Connectivity and Vehicular Traffic Prediction Based on Machine Learning Approaches</a><br><strong>2015 IEEE 82nd Vehicular Technology Conference (VTC2015-Fall)</strong></td><td>【已下载】</td></tr><tr><td>Deep Sequence Learning with Auxiliary Information<br><strong>arxiv - 2018【浙大】</strong></td><td>【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/8500541" target="_blank" rel="noopener">Decision-Theoretic Cooperative Parking for Connected Vehicles: an Investigation</a><br><strong>2018 IEEE Intelligent Vehicles Symposium (IV) （顶会）</strong></td><td>a decentralized coordination approach was introduced to search the car parking spots, which is applicable to large car park areas.【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/8409450" target="_blank" rel="noopener">Spatio-Temporal Network Traffic Estimation and Anomaly Detection Based on Convolutional Neural Network in Vehicular Ad-Hoc Networks</a><br><strong>IEEE ACCESS 2018 （SCI 2区）</strong></td><td>SPATIO-TEMPORAL NETWORK TRAFFIC ESTIMATION IN VANETs【已下载】</td></tr><tr><td><a href="https://arxiv.org/abs/1803.11115" target="_blank" rel="noopener">Deep reinforcement learning for traffic light control in vehicular networks</a><br><strong>Arxiv 2018</strong></td><td>In this work the traffic intersection scenario contains multiple phases, which represents a high-dimension action space. The work also guarantees that the traffic signal time smoothly changes between two neighboring actions.【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/8500414" target="_blank" rel="noopener">Adaptive Traffic Signal Control with Deep Recurrent Q-learning</a><br><strong>2018 IEEE Intelligent Vehicles Symposium (IV) 顶会</strong></td><td>【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/6894591" target="_blank" rel="noopener">Traffic flow prediction with big data: A deep learning approach</a><br><strong>IEEE Transactions on Intelligent Transportation Systems 2015</strong></td><td>【已下载】</td></tr><tr><td>Deep sequence learning with auxiliary information for traffic prediction<br><strong>Arxiv 2018</strong></td><td>【已下载】</td></tr><tr><td><a href="https://www.sciencedirect.com/science/article/pii/S2214209618300263" target="_blank" rel="noopener">A swarm algorithm for collaborative traffic in vehicular networks</a><br><strong>Vehicular Communications 2018（SCI 2区）</strong></td><td>【已下载】</td></tr><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/8412487" target="_blank" rel="noopener">A Demand-Supply Oriented Taxi Recommendation System for Vehicular Social Networks</a><br><strong>IEEE ACCESS 2018 （SCI 2区）</strong></td><td>【已下载】</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p><img alt="An illustration of AI oriented V2X applications." data-src="/images/%E4%BB%8E%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E7%9C%8BAI%E4%B8%8E%E8%BD%A6%E8%81%94%E7%BD%91%E7%9A%84%E8%9E%8D%E5%90%88%E5%8F%91%E5%B1%95%E3%80%90%E9%99%84%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E3%80%91/1570414575930.png" class="lozad"></p><p><img alt="Overall representation of AI applied to V2X applications" data-src="/images/%E4%BB%8E%E6%96%87%E7%8C%AE%E7%BB%BC%E8%BF%B0%E7%9C%8BAI%E4%B8%8E%E8%BD%A6%E8%81%94%E7%BD%91%E7%9A%84%E8%9E%8D%E5%90%88%E5%8F%91%E5%B1%95%E3%80%90%E9%99%84%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87%E3%80%91/1570428229693.png" class="lozad"></p><p>待解决问题：</p><ul><li>traffic flow prediction</li></ul><p>感兴趣问题：</p><ul><li>防碰撞</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于AI与车联网的融合发展，我将在本文中对几篇文献综述中所提到的信息进行总结，并将在最后进行整体归纳。在此向文献综述的作者们致以崇高的谢意。&lt;/p&gt;
&lt;h1 id=&quot;popular-content-distribution-in-public-transportation-
      
    
    </summary>
    
      <category term="车联网" scheme="https://yinyoupoet.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91/"/>
    
    
      <category term="AI" scheme="https://yinyoupoet.github.io/tags/AI/"/>
    
      <category term="车联网" scheme="https://yinyoupoet.github.io/tags/%E8%BD%A6%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>我选择</title>
    <link href="https://yinyoupoet.github.io/2019/10/03/%E6%88%91%E9%80%89%E6%8B%A9/"/>
    <id>https://yinyoupoet.github.io/2019/10/03/我选择/</id>
    <published>2019-10-03T03:39:41.000Z</published>
    <updated>2019-10-03T04:06:52.000Z</updated>
    
    <content type="html"><![CDATA[<center><span style="font-size:2em;">我选择</span><p>我选择紫色，<br>我选择早睡早起早出早归。</p><p>我选择冷粥，破砚，晴窗，<br>忙人之所闲而闲人之所忙。</p><p>我选择非必不得已，<br>一切事，无分巨细，总自己动手。</p><p>我选择人一能之己十之，人十能之己百之。</p><p>我选择以水为师──高处高平，低处低平。</p><p>我选择以草为性命，<br>如卷施，根拔而心不死。</p><p>我选择高枕，地牛动时，亦欣然与之俱动。</p><p>我选择岁月静好，猕猴亦知吃果子拜树头。</p><p>我选择读其书诵其诗，而不必识其人。</p><p>我选择不妨有佳篇而无佳句。</p><p>我选择好风如水，有不速之客一人来。</p><p>我选择轴心，而不漠视旋转。</p><p>我选择春江水暖，竹外桃花三两枝。</p><p>我选择渐行渐远，<br>渐与夕阳山外山外山为一，<br>而曾未偏离足下一毫末。</p><p>我选择电话亭：多少是非恩怨，虽经于耳，不入于心。</p><p>我选择鸡未生蛋，蛋未生鸡，<br>第一最初威音王如来未降迹。</p><p>我选择江欲其怒，涧欲其清，路欲其直，<br>人欲其好德如好色。</p><p>我选择无事一念不生，有事一心不乱。</p><p>我选择迅雷不及掩耳。</p><p>我选择最后一人成究竟觉。</p></center><hr><center><b>作者：周梦蝶</b></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;
&lt;span style=&quot;font-size:2em;&quot;&gt;我选择&lt;/span&gt;
&lt;p&gt;我选择紫色，&lt;br&gt;
我选择早睡早起早出早归。&lt;/p&gt;
&lt;p&gt;我选择冷粥，破砚，晴窗，&lt;br&gt;
忙人之所闲而闲人之所忙。&lt;/p&gt;
&lt;p&gt;我选择非必不得已，&lt;br&gt;
一切事，无分
      
    
    </summary>
    
      <category term="诗歌" scheme="https://yinyoupoet.github.io/categories/%E8%AF%97%E6%AD%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>LaTeX笔记</title>
    <link href="https://yinyoupoet.github.io/2019/09/20/LaTeX%E7%AC%94%E8%AE%B0/"/>
    <id>https://yinyoupoet.github.io/2019/09/20/LaTeX笔记/</id>
    <published>2019-09-20T07:30:44.000Z</published>
    <updated>2019-10-07T02:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对LaTeX使用或阅读中遇到的问题及其答案进行总结，不对基础知识做出详细介绍。</p><p>注：本文部分内容来源于网络，参考网站已标注于文章末尾，由于参考资料较多，因此不在文中每处引用处进行标记。</p><h2 id="beginfigureh-的h的含义"><a class="markdownIt-Anchor" href="#beginfigureh-的h的含义"></a> \begin{figure}[H] 的[H]的含义</h2><p>当插入图片、表格等的时候，往往因为其篇幅较大、且往往含有标题等原因，有可能跨越多个页面或造成排版上的问题，因此LaTeX会将其设置为<strong>浮动体</strong>，并自动对其位置进行调整，而如何调整其位置的方法也是可选的。</p><p>LaTeX算法可接受位置描述符等参数调配图表位置。位置描述符有以下几种:</p><table><thead><tr><th><strong>描述符</strong></th><th><strong>期望位置</strong></th></tr></thead><tbody><tr><td>h</td><td>将浮动体放在这里(Latex会根据其排版美学做调整) <br>Place the float here, i.e., approximately at the same point it occurs in the source text (however, not exactly at the spot) )</td></tr><tr><td>t</td><td>将浮动体放在页的顶部<br> Position at the top of the page.</td></tr><tr><td>b</td><td>将浮动体放在页的底部<br> Position at the bottom of the page.</td></tr><tr><td>p</td><td>将浮动体单独成页<br> Put on a special page for floats only.</td></tr><tr><td>l</td><td>忽略LaTeX的排版美学内置参数<br> Override internal parameters LaTeX uses for determining “good” float positions.</td></tr><tr><td>H</td><td>将浮动体强制放在这里<br> Places the float at precisely the location in the LaTeX code. Requires the float package,i.e., \usepackage{float}. This is somewhat equivalent to !ht.</td></tr></tbody></table><h2 id="latex的公式中字体设置为正体"><a class="markdownIt-Anchor" href="#latex的公式中字体设置为正体"></a> LaTeX的公式中字体设置为正体</h2><p>LaTex中默认的公式中字体为斜体，如<code>P_x</code></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">P_x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>但如果想让其下标为正体，那么可以写作：<code>P_{\rm x}</code></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi mathvariant="normal">x</mi></msub></mrow><annotation encoding="application/x-tex">P_{\rm x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">x</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>除了\rm外，还可以设置为其他字体，需要引入不同的包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\usepackage&#123;bm&#125;       % 粗斜体 \bm</span><br><span class="line">\usepackage&#123;bbm&#125;      % \mathbbm, \mathbbss, \mathbbmtt</span><br><span class="line">\usepackage&#123;dsfont&#125;   % \mathds</span><br><span class="line">\usepackage&#123;yfonts&#125;   % \textfrak, \textswab</span><br><span class="line">\usepackage&#123;amssymb&#125;  % \mathfrak, \mathcal</span><br><span class="line">\usepackage&#123;mathrsfs&#125; % \mathscr, 不同于\mathcal or \mathfrak 之类的英文花体字体%产生拉普拉斯变换式的字母</span><br></pre></td></tr></table></figure><h2 id="includegraphicswidth95textwidthxxxeps的含义"><a class="markdownIt-Anchor" href="#includegraphicswidth95textwidthxxxeps的含义"></a> \includegraphics[width=.95\textwidth]{xxx.eps}的含义</h2><p>上述命令是用于插入图片的，这点毋庸置疑，但是<code>[width=.95\textwidth]</code>是何意呢？</p><p>事实上，它表示 <strong>插入图形的宽度为文本行宽的 95%</strong></p><p>关于其他参数请参看：<a href="https://blog.csdn.net/king0406/article/details/51252298" target="_blank" rel="noopener">LaTex技巧[22]：LaTex插图命令includegraphics参数详解</a></p><h2 id="latex中thebibliography后面的数字的含义"><a class="markdownIt-Anchor" href="#latex中thebibliography后面的数字的含义"></a> Latex中thebibliography后面的数字的含义</h2><p><img alt="图源见图片" data-src="/images/LaTeX%E7%AC%94%E8%AE%B0/1569032008429.png" class="lozad"></p><h2 id="continuedfloat的用法"><a class="markdownIt-Anchor" href="#continuedfloat的用法"></a> \ContinuedFloat的用法</h2><p><img alt data-src="/images/LaTeX%E7%AC%94%E8%AE%B0/1569032098655.png" class="lozad"></p><h2 id="latex表格中multirow的使用"><a class="markdownIt-Anchor" href="#latex表格中multirow的使用"></a> LaTeX表格中\multirow的使用</h2><p><img alt data-src="/images/LaTeX%E7%AC%94%E8%AE%B0/1569032152696.png" class="lozad"></p><hr><p>参考资料：</p><ol><li><a href="https://blog.csdn.net/cocoonyang/article/details/78036326" target="_blank" rel="noopener">  LaTex 入门</a></li><li><a href="https://blog.csdn.net/raby_gyl/article/details/82991976" target="_blank" rel="noopener">latex数字字体</a></li><li><a href="https://blog.csdn.net/king0406/article/details/51252298" target="_blank" rel="noopener">LaTex技巧[22]：LaTex插图命令includegraphics参数详解</a></li><li><a href="https://blog.csdn.net/sdujava2011/article/details/53078827" target="_blank" rel="noopener">Latex中thebibliography后面的数字的含义</a></li><li><a href="https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions" target="_blank" rel="noopener">LaTeX/Floats, Figures and Captions</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文针对LaTeX使用或阅读中遇到的问题及其答案进行总结，不对基础知识做出详细介绍。&lt;/p&gt;
&lt;p&gt;注：本文部分内容来源于网络，参考网站已标注于文章末尾，由于参考资料较多，因此不在文中每处引用处进行标记。&lt;/p&gt;
&lt;h2 id=&quot;beginfigureh-的h的含义&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="实用工具" scheme="https://yinyoupoet.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="LATEX" scheme="https://yinyoupoet.github.io/tags/LATEX/"/>
    
  </entry>
  
  <entry>
    <title>关于AI赋能车联网的研究现状</title>
    <link href="https://yinyoupoet.github.io/2019/09/17/%E5%85%B3%E4%BA%8EAI%E8%B5%8B%E8%83%BD%E8%BD%A6%E8%81%94%E7%BD%91%E7%9A%84%E7%A0%94%E7%A9%B6%E7%8E%B0%E7%8A%B6/"/>
    <id>https://yinyoupoet.github.io/2019/09/17/关于AI赋能车联网的研究现状/</id>
    <published>2019-09-17T14:41:07.000Z</published>
    <updated>2019-10-05T07:40:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会将AI与车联网相关的顶会文章进行总结，并将其按相关度分成五个等级，并对每一篇文章进行简短的总结与介绍。</p><h2 id="s级"><a class="markdownIt-Anchor" href="#s级"></a> S级</h2><table><thead><tr><th>标题</th><th>总结</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="a级"><a class="markdownIt-Anchor" href="#a级"></a> A级</h2><table><thead><tr><th>标题</th><th>总结</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://uwspace.uwaterloo.ca/handle/10012/14908" target="_blank" rel="noopener">Popular Content Distribution in Public Transportation Using Artificial Intelligence Techniques</a></td><td>基于人工智能，利用公共交通（公交车），卸载室外无线网络负载。（注：论文无法下载，已向网站发送请求邮件）</td><td>邮件发出去很久了但一直没回复，估计不会回复了</td></tr><tr><td><a href="https://ieeexplore.ieee.org/document/8485876" target="_blank" rel="noopener">FML: Fast Machine Learning for 5G mmWave Vehicular Communications</a><br><strong>IEEE INFOCOM 2018</strong></td><td><span style="background:#ff8a80;color:#fff">【在线ML算法实现基站的mmWare波束智能选择】</span>5G的V2X的通信将主要采用mmWare以满足Gbps这种高带宽的需求，但mmWare具有一些缺点：有方向、易被阻挡。因此该文章提出了一种在线的基于环境感知的智能自适应mmWare波束选择算法，叫做FML（Fast Machine Learning）。这里的波束选择是针对于基站而言的，因为基站发送的信号极易被建筑物遮挡。FML是针对5G蜂窝网络的特性进行设计的，此算法能够针对附近建筑物、车辆拥塞等情景进行自适应mmWare的波束选择（已下载）</td><td>multi-armed bandit problem（多臂老虎机问题，属于强化学习的一种推荐算法）</td></tr></tbody></table><blockquote><p>邮件内容：</p><p>Dear Professor,<br>    I’m a postgraduate student in China who’s a greenhand towards the domain of ‘Internet of Vehicles’, and fortunately have I read the abstract of your luminous paper named ‘Popular Content Distribution in Public Transportation Using Artificial Intelligence Techniques’ which have really interested me that I’d like to learn more about your brilliant thoughts in your prescient paper, so I’ll deeply apperciate you if you could give me a copy of your paper, thanks a lot!</p></blockquote><h2 id="b级"><a class="markdownIt-Anchor" href="#b级"></a> B级</h2><table><thead><tr><th>标题</th><th>总结</th></tr></thead><tbody><tr><td><a href="https://ieeexplore.ieee.org/document/8605302" target="_blank" rel="noopener">Artificial Intelligence for Vehicle-to-Everything: A Survey</a><br><strong>IEEE ACCESS-2019.1.8</strong></td><td><span style="background:#ff8a80;color:#fff">【文献综述】</span>一个关于AI与V2X的文献综述。V2X发展有三个方向：交通效率、道路安全、能源利用率。文中提出了一些ML在V2X中的应用场景：提高出行安全与舒适度、速度建议、合作停车（V2V寻找空闲车位等）、VANET中的时空网络流量估计、交通信号灯控制等等（已下载）</td></tr><tr><td><a href="https://ieeexplore.ieee.org/document/8406895" target="_blank" rel="noopener">Hierarchical architecture for 5G based software-defined intelligent transportation system</a><br><strong>IEEE INFOCOM 2018</strong></td><td><span style="background:#ff8a80;color:#fff">【基于5G的适用于VANET的新型网络架构】</span>架构解决了传统VANET中ITS和SDN（Software Define-Network）之间通信的带宽和持续连接之间的问题（已下载）</td></tr><tr><td><a href="https://www.sciencedirect.com/science/article/pii/S157087051930160X?via%3Dihub" target="_blank" rel="noopener">A two-tier machine learning-based handover management scheme for intelligent vehicular networks</a><br><strong>Ad Hoc Networks - 2019.7.19</strong></td><td><span style="background:#ff8a80;color:#fff">【车载移动网络接入点无缝切换的双层机器学习算法】</span>传统移动网络协议无法满足高速运动和无线接入点的频繁切换的需要，移动IP切换会导致高延迟和高丢包率，因此本文提出一种实现移动接入点无缝切换的机器学习算法。该算法分两层，第一层使用循环神经网络预测接收到的无线接入点的信号强度，从而判断是否需要进行接入点的切换；第二层使用隐马尔可夫模型来选择合适的无线接入点以进行接入。（已下载）</td></tr><tr><td><a href="https://www.sciencedirect.com/science/article/pii/S1389128618305267?via%3Dihub" target="_blank" rel="noopener">Safety and efficiency control protocol for highways using intelligent vehicular networks</a><br><strong>Computer Networks - 2019.4</strong></td><td><span style="background:#ff8a80;color:#fff">【避免高速公路交通事故的一种协议】</span>一种基于ITS的网络协议，用于在高速公路上前车出现事故时向后车发送信息并提出一种可行的操作方案，如加速、减速、变道、停车等以避免严重的交通事故发生（已下载）</td></tr><tr><td><a href="https://ieeexplore.ieee.org/abstract/document/8345672" target="_blank" rel="noopener">Machine Learning for Vehicular Networks: Recent Advances and Application Examples</a><br><strong>ieee vehicular technology magazine -</strong> <strong>2018.6</strong></td><td><span style="background:#ff8a80;color:#fff">【文献综述】</span>是一个机器学习在车联网中的研究现状的一个文献综述。其提出，使用机器学习在车联网中有如下应用场景：<br>1、监督学习：入侵、错误、异常检测，吞吐量预测，通道参数回归<br>2、无监督学习：拥塞控制，分级路由选择，数据聚合<br>3、增强学习：资源管理，路由选择<br>其提出的具体的ML在车联网中的应用包括：<u>交通流预测、网络拥塞控制、智能无线资源管理、负载平衡和垂直控制、虚拟资源分配、分布式资源管理</u>等（已下载）</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="c级"><a class="markdownIt-Anchor" href="#c级"></a> C级</h2><table><thead><tr><th>标题</th><th>总结</th></tr></thead><tbody><tr><td><a href="https://arxiv.org/abs/1906.00400" target="_blank" rel="noopener">Mobile Edge Intelligence and Computing for the Internet of Vehicles</a><br><strong>Arxiv（尚未正式发布）- 2019.6</strong></td><td><span style="background:#ff8a80;color:#fff">【文献综述】</span>IOT时代，特别在车辆中，车载处理单元和云计算无法满足大量数据的处理与存储需求，因此需要边缘信息系统来进行辅助，包括边缘缓存、边缘计算、边缘AI，而应用场景则包括：边缘联合感知、地图、定位等等（已下载）</td></tr><tr><td><a href="https://ieeexplore.ieee.org/document/8756239" target="_blank" rel="noopener">Intelligent Intersection Management Systems Considering Autonomous Vehicles: A Systematic Literature Review</a><br><strong>IEEE Access - 2019.7</strong></td><td><span style="background:#ff8a80;color:#fff">【文献综述】</span>自动驾驶在交叉路口的一些方法的文献综述，包括ITS和通信技术，但占比不大（已下载）</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="d级"><a class="markdownIt-Anchor" href="#d级"></a> D级</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文将会将AI与车联网相关的顶会文章进行总结，并将其按相关度分成五个等级，并对每一篇文章进行简短的总结与介绍。&lt;/p&gt;
&lt;h2 id=&quot;s级&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#s级&quot;&gt;&lt;/a&gt; S级&lt;/h2&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>观“边缘计算+5G：赋能边缘，共塑未来”有感</title>
    <link href="https://yinyoupoet.github.io/2019/09/12/%E8%A7%82%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97-5G%E9%87%8D%E5%A1%91%E6%9C%AA%E6%9D%A5%E6%9C%89%E6%84%9F/"/>
    <id>https://yinyoupoet.github.io/2019/09/12/观边缘计算-5G重塑未来有感/</id>
    <published>2019-09-12T08:53:29.000Z</published>
    <updated>2019-09-12T11:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>如今机器学习、大数据、5G、云计算等高新技术正迅猛发展，信息2.0时代即将到来，该时代应当具有智能、无人、自主这三大特点。</p><p>可以预见在5G时代中，接入网络中的设备数将会继续增加，截至目前加入网络的设备数量已经达到了千亿级。而随着传输速率、带宽等的大幅提高，每日在网络上传输的数据甚至将会需要以ZB来计算，这些变化对算力、存储的要求自然是极高的。在过去，我们对于这种超级大量的计算都是使用云计算、分布式等技术来进行处理，但是实际上云计算的算力和存储能力也都不是无限的，而且云计算往往也难以满足大用户量场景下低时延的要求，这对于车联网、VR直播或游戏等的局限是很大的。而由于过去的技术已渐渐无法满足人们日益增长的对美好生活的向往，因此在今年上半年边缘计算这一概念逐渐流行了起来。</p><p>边缘计算与云计算是一个互补的关系，我们大可将对实时性要求高的计算请求在边缘侧进行计算，而将对时延不敏感的数据传回云数据中心进行处理。通过将人工智能、大数据、云计算、5G、边缘计算等技术相结合，就能实现一种新型的边缘智能计算网络架构，在网络边缘侧进行一定量的数据存储与数据计算，实现云边协同，从而大幅降低网络时延。此外，边缘计算也缓解了云计算中存在的数据安全问题，由于云计算中数据大都集中存储在一个或几个存储服务器中，因此一旦出现安全事故，将会产生非常严重的影响，而边缘计算可以将用户隐私数据分布储存在网络边缘侧，能够在一定程度上降低数据泄露等事故的严重性。</p><p>未来的网络必然是AI + Big Data + Cloud Computing + 5G + Edge Computing模式，5G赋能的边缘计算尚有极大的发展空间，其势必将成长为能够与云计算平分秋色的新兴市场。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如今机器学习、大数据、5G、云计算等高新技术正迅猛发展，信息2.0时代即将到来，该时代应当具有智能、无人、自主这三大特点。&lt;/p&gt;
&lt;p&gt;可以预见在5G时代中，接入网络中的设备数将会继续增加，截至目前加入网络的设备数量已经达到了千亿级。而随着传输速率、带宽等的大幅提高，每日
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我看“车联网”</title>
    <link href="https://yinyoupoet.github.io/2019/09/08/%E6%88%91%E7%9C%8B%E2%80%9C%E2%80%9C%E8%BD%A6%E8%81%94%E7%BD%91%E2%80%9D/"/>
    <id>https://yinyoupoet.github.io/2019/09/08/我看““车联网”/</id>
    <published>2019-09-08T10:52:03.000Z</published>
    <updated>2019-11-20T11:00:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="车联网简介"><a class="markdownIt-Anchor" href="#车联网简介"></a> 车联网简介</h2><p>车联网，Internet of Vehicles（IoV）,是物联网（IoT）中的一个重要组成部分。它是由传统车辆Ad-hoc网络演变而来<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，并继承了物联网“万物互联”的思想，其核心思想就是Vehicle to Everything（V2X），V2X包括并不限于以下几种<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><ul><li>V2V（Vehicle to Vehicle）：车与车</li><li>V2P（Vehicle to Pedestrian）：车与行人</li><li>V2R（Vehicle to Road）：车与路</li><li>V2I（Vehicle to Infrastructure）：车与基础设施</li><li>V2N（Vehicle to Network）：车与网络</li><li>V2C（Vehicle to Cloud）：车与云</li></ul><h3 id="v2x的作用"><a class="markdownIt-Anchor" href="#v2x的作用"></a> V2X的作用</h3><p>在大唐电信关于V2X车联网的介绍中，提出了V2X有如下几点作用：</p><ul><li>主要用于实现车间信息共享与协同控制的<strong>通信保障</strong></li><li>与传统车载激光雷达、毫米波雷达、摄像头、超声波等车载感知设备优势互补，为自动驾驶汽车提供雷达无法实现的<strong>超视距和复杂环境感知能力</strong></li><li>和周边车辆、道路、基础设施进行通信，从时间、空间维度扩大了车辆对交通与环境的<strong>感知范围</strong>，能够提前获知周边车辆操作信息、交通控制信息、拥堵预测信息、视觉盲区等周边环境信息</li><li>增强环境感知能力、降低车载传感器成本、使能<strong>多车信息融合决策</strong></li></ul><h3 id="车联网的发展目标"><a class="markdownIt-Anchor" href="#车联网的发展目标"></a> 车联网的发展目标</h3><p>在5G时代，伴随着硬件发展带来的算力的飞速增加，以及机器学习、神经网络等学科的快速发展，车联网有极大的商业利益和研究价值，其未来的发展目标如下<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>：</p><ul><li>提高交通效率，改善汽车驾乘感受，构建汽车和交通服务新业态，为用户提供<strong>智能、舒适、安全、节能、高效</strong>的综合服务</li><li>避免交通事故、提升道路安全、缓解拥堵、提高交通效率、降低能耗、降低环境污染</li></ul><h3 id="前装车联网和后装车联网"><a class="markdownIt-Anchor" href="#前装车联网和后装车联网"></a> 前装车联网和后装车联网<sup class="footnote-ref"><a href="#fn2" id="fnref2:1">[2:1]</a></sup></h3><p>根据车联网硬件设备的安装时间可以简单地将车联网分成<strong>前装车联网</strong>和<strong>后装车联网</strong>。一辆汽车在出厂时就会包含很多硬件设备，比如空调、发动机、轮胎、摄像头等等，这些部件可以安装上各式各样的传感器，并由一个系统对其进行数字化、信息化管理，车辆内部各种数据之间的传输所组成的网络成为<strong>车内网</strong>。在车内网中，传感器很关键，除了采集车内信息外，它还需监测车辆外部的各种信息，比如防碰撞传感器、行车记录仪等等。</p><p><img alt="图源见水印" data-src="https://pic2.zhimg.com/v2-53dd3e20beeafb886a68a6625dacb9b1_b.jpg" class="lozad"></p><p>除了传感器之外，车辆内部还需要一套控制系统用于车辆的整体协调与管理。在汽车生产商生产汽车时，预装的车联网设备就称之为“前装车联网”，相应的，出厂后安装的车联网设备就称之为“后装车联网”。</p><p>前装车联网系统一般包括四部分：主机、车载T-BOX，手机APP及后台系统。其中，T-BOX，全名Telematics BOX，又称TCU（车联网控制单元），是安装在汽车上用于控制和跟踪汽车状态的一台嵌入式计算机。</p><p>由互联网公司等非汽车制造商安装的车载终端就称为后装车联网。无论是前装还是后装，其目的都是为了获取数据，监测和控制车辆。而在如今的5G时代，单单是车辆与其所有者之间简单的数据交互已经不能满足人们的需要了，我们更需要的是车辆与外部设备之间进行高速、稳定的数据通信，从而更好的保证行车安全，提高行车效率，改善驾乘体验。</p><h2 id="车联网通信技术"><a class="markdownIt-Anchor" href="#车联网通信技术"></a> 车联网通信技术</h2><p>车辆拥有移动速度快、移动范围广等特点，加之其对信息传递的精度和速度都有极高的要求，因此它的通信是比较困难的，而目前比较常见的车联网通信技术就是DSRC和LTE-V。</p><h3 id="dsrc"><a class="markdownIt-Anchor" href="#dsrc"></a> DSRC<sup class="footnote-ref"><a href="#fn2" id="fnref2:2">[2:2]</a></sup></h3><p>DSRC全名为Dedicated Short Range Communications，即专用短程通信技术，是以美国为代表的许多国家遵循的主流车联网通信技术。它需要在路边安装许多<strong>路侧单元</strong>(Road Side Unit，RSU)，用于接收<strong>车载单元</strong>(On Board Unit，OBU)所发送的信号，或向车辆转发信息，此外，它还可以将信号通过网络传递给<strong>智能交通系统</strong>(Intelligent Transport System，ITS)进行分析与处理。其可以简单地认为是在路边装wifi，然后车辆通过这个wifi进行通信。</p><p><img alt="出处见水印" data-src="/images/%E6%88%91%E7%9C%8B%E2%80%9C%E2%80%9C%E8%BD%A6%E8%81%94%E7%BD%91%E2%80%9D/v2-aece5053a5812c051a67987d2a843778_b.jpg" class="lozad"></p><p>DSRC如其名称所言，“专用短程通信”，具有通信距离短的局限性，如果距离长了，则其可靠性等方面会存在问题，而LTE-V技术就是一个很好的解决方案。</p><h3 id="lte-v"><a class="markdownIt-Anchor" href="#lte-v"></a> LTE-V<sup class="footnote-ref"><a href="#fn2" id="fnref2:3">[2:3]</a></sup></h3><p>LTE-V采用的是蜂窝移动通信技术，具有通信距离长、带宽高等特点。目前主流的蜂窝通信技术就是4G LTE，而LTE-V就是给车联网量身定制的LTE。它依托了现在已经建成的LTE基站，避免了DSRC所需的RSU的重复建设，且覆盖范围更广泛，传输速率和带宽也更高。</p><p><img alt="图源见水印" data-src="/images/%E6%88%91%E7%9C%8B%E2%80%9C%E2%80%9C%E8%BD%A6%E8%81%94%E7%BD%91%E2%80%9D/v2-1dd68416eeefc9e98b113a5505d7c3ef_b.jpg" class="lozad"></p><p><img alt="图源见水印" data-src="/images/%E6%88%91%E7%9C%8B%E2%80%9C%E2%80%9C%E8%BD%A6%E8%81%94%E7%BD%91%E2%80%9D/v2-1cf139f23748cb1a083f34c1abde21c1_b.jpg" class="lozad"></p><p>LTE-V包括两种工作模式，分别是集中式（LTE-V-Cell）和分布式（LTE-V-Direct），其中集中式需要基站作为控制中心，实现大带宽、大覆盖范围的通信，而分布式则无需基站作为支撑，可直接实现车辆与车辆、车辆与周边环境节点之间的通信。若车辆在十字路口由于建筑物的遮挡不能直接交互低时延安全业务，此时可以通过基站或路侧设备的转发，获得车辆间的道路安全信息。</p><p>目前DSRC与LTE-V两种标准之间竞争激烈，而国内更倾向于采用LTE-V。</p><h3 id="nr-v2x"><a class="markdownIt-Anchor" href="#nr-v2x"></a> NR-V2X</h3><p>5G时代的到来也为车联网的发展提供了极大的动力，5G相对于4G而言能够提供10倍的传输速率，它能够将车联网的网络时延降低到毫秒级（ms），这为车联网的发展提供了无限可能，而LTE-V在5G的加持下，就可以演进成NR-V2X。相对LTE-V而言，它拥有更高的带宽、更短的时延和更多的连接数量。</p><h2 id="车联网网络层前沿研究与分析"><a class="markdownIt-Anchor" href="#车联网网络层前沿研究与分析"></a> 车联网网络层前沿研究与分析</h2><h3 id="车联网与移动边缘计算"><a class="markdownIt-Anchor" href="#车联网与移动边缘计算"></a> 车联网与移动边缘计算</h3><p>移动边缘计算（Mobile Edge Computing, MEC）是一个软件与硬件相结合所形成的系统，它能够在网络边界为车辆提供强大的计算能力。车载单元的计算能力和计算速度往往比较有限，而在5G时代，边缘计算能够为车载终端提供低时延、高效率的数据处理与分析能力，能为自动驾驶、智慧城市等提供极大的技术支撑。边缘计算相对于云计算而言，具有即时性更高、传播时延更小的特点，具有很广阔的应用场景。</p><h3 id="lte-v-direct网络传输方式设计与优化"><a class="markdownIt-Anchor" href="#lte-v-direct网络传输方式设计与优化"></a> LTE-V Direct网络传输方式设计与优化</h3><p>论文<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>中对LTE-V Direct的MAC过程进行建模，并计算出了LTE-V-Direct的帧信息丢失率和接收间隙。因此可以试想，提出一种基于LTE-V Direct的网络传输方式，尽量提高车辆间数据传输效率。</p><h3 id="车辆超视距"><a class="markdownIt-Anchor" href="#车辆超视距"></a> 车辆超视距</h3><p>在车辆因前方车辆遮挡无法及时看见前方障碍物、前方转角有障碍物遮挡等影响车辆驾驶人视野范围的驾驶场景下，往往容易发生交通事故。因此可以基于LTE-V Direct技术，实时向驾驶人展示其他车辆所能看到的路况信息，比如在同方向近距离跟车行驶或者车队行驶时，可以获得前车的视野，以及时规避前方道路障碍，避免前车急刹车造成的追尾等事故。</p><h3 id="车队或跟车行驶的车辆速度同步控制"><a class="markdownIt-Anchor" href="#车队或跟车行驶的车辆速度同步控制"></a> 车队或跟车行驶的车辆速度同步控制</h3><p>论文<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>中提出了一种基于相对距离和相对速度设计的新型防碰撞系统，使后方车辆可以跟随前车的速度变化而变化，使行车距离一直保持在安全范围外。因此可以考虑将其引申，可以使两车保持一个合适的距离从而形成车队，后车的行驶速度、方向等均与前车保持一致，从而形成“公路火车”，适用于高速公路上行驶的车队，或者用于城市中的智能辅助跟车行驶等。</p><h3 id="车辆密度监测"><a class="markdownIt-Anchor" href="#车辆密度监测"></a> 车辆密度监测</h3><p>现在使用的车辆密度监测常为使用视频识别、图像处理等方式来进行密度估计，但是往往无法精确知道车辆前进速度、指定路段上车辆数量等数据，而可以考虑使用路边基站实时与道路车辆进行通信，通过车辆位移、速度等可以准确监测道路拥堵情况，也可以准确得知道路车辆数量。准确的数据能够提供给交通管理部门进行更好的数据分析与城市交通规划。</p><h3 id="车联网信息安全"><a class="markdownIt-Anchor" href="#车联网信息安全"></a> 车联网信息安全</h3><p>机器学习所建立的模型往往是可以被攻击的，因此自动驾驶仅凭计算机视觉并不能保证真正的安全，而结合V2X，则可以得到更高的安全保证。然而，车联网系统同样可以受到攻击，车辆可能会接收到恶意虚假消息，从而引发较为严重的交通事故。然而车辆往往是行驶在陌生的环境下，无法判断接收到的信息的可信度，而论文<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>中提出了一种基于区块链的车载网络中的分散式信任管理系统，车辆可以使用贝叶斯推理模型验证来自相邻车辆的接收消息。基于验证结果，车辆将为每个消息源车辆生成评级，由RSU来维护信任区块链。</p><p>而论文<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>则提出一种基于车辆实际速度与使用V2V进行通信速度估计从而预估车辆间距，从而避免Sybil攻击的模型。</p><h3 id="高速故障信息传递"><a class="markdownIt-Anchor" href="#高速故障信息传递"></a> 高速故障信息传递</h3><p>高速公路上自动向后方发送车辆故障信息，提前提醒后车驾驶员引起注意，通过信号传播时延判断距离。必要时可由车辆间形成网络，也方便救援车辆行进。同时，救援车辆可以向周围车辆发送信息以提前让出通路。</p><h3 id="其他方面"><a class="markdownIt-Anchor" href="#其他方面"></a> 其他方面</h3><ul><li>车联网 + 边缘计算</li><li>新型车联网专用网络架构（或对传输时延敏感的传输协议）</li><li>车辆间的智能协同通信与协同计算，实现算力的最大化，或实现通信与算力的同步（高效利用）</li><li>安全问题，包括边缘设备的安全问题</li><li>云边协同的更高效率的策略</li><li>基于交通信号灯的车速引导（实现一路绿灯，同时需要综合考虑前方车辆数量及其行驶速度以及拥堵程度）</li><li>多接入边缘计算MEC</li><li>建立基于机器学习的路由选择模型，自动对网络进行适配并选取最优的方案</li><li>车间网络链路的生存周期预测</li><li>车间信息广播协议：拟提出一种新方法，传统的协议往往适用于解决网络洪泛所带来的巨大开销，因而往往采用某种算法对中间结点进行选择以控制信息数量，但是这种方法难免存在利用率低的情况，因此或可提出一种带响应的覆盖全网络的异步广播协议，其允许存在可接受范围内的信息冗余，并最大化网络利用率。</li><li>等等</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Yang F , Wang S , Li J , et al. An overview of Internet of Vehicles[J]. China Communications, 2014, 11(10):1-15. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>小枣君.关于“<em>车联网</em>”的最强科普！[EB/OL].<a href="https://zhuanlan.zhihu.com/p/51408781" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51408781</a>, 2018-12-03. <a href="#fnref2" class="footnote-backref">↩︎</a> <a href="#fnref2:1" class="footnote-backref">↩︎</a> <a href="#fnref2:2" class="footnote-backref">↩︎</a> <a href="#fnref2:3" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>陈山枝, 胡金玲, 时岩, 赵丽. LTE-V2X车联网技术、标准与应用. 电信科学[J], 2018, 34(4): 1-11 doi:10.11959/j.issn.1000-0801.2018140. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Jiayang Li, Mengkai Shi, et al. Media Access Process Modeling of LTE-V-Direct Communication Based on Markov Chain[C]. 2018 IEEE Intelligent Vehicles Symposium (IV), 2018. <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>Yibing Zhao, Xiumei Xiang, et al. Longitudinal Control Strategy of Collision Avoidance Warning System for Intelligent Vehicle Considering Drivers and Environmental Factors[C]. 2018 IEEE Intelligent Vehicles Symposium (IV), Changshu, China, 2018. <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>Yang Z , Yang K , Lei L , et al. Blockchain-based Decentralized Trust Management in Vehicular Networks[J]. IEEE Internet of Things Journal, 2018:1-1. <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>Ayaida M., Messai N., Najeh S., Wilhelm G. (2019) Cyber Attack Detection Algorithm Using Traffic Flow Theory. In: Hilt B., Berbineau M., Vinel A., Jonsson M., Pirovano A. (eds) Communication Technologies for Vehicles. Nets4Cars/Nets4Trains/Nets4Aircraft 2019. Lecture Notes in Computer Science, vol 11461. Springer, Cham <a href="#fnref7" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;车联网简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#车联网简介&quot;&gt;&lt;/a&gt; 车联网简介&lt;/h2&gt;
&lt;p&gt;车联网，Internet of Vehicles（IoV）,是物联网（IoT）中的一个重要组成部分。它是由传统车辆Ad-hoc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo博客进行百度、谷歌SEO</title>
    <link href="https://yinyoupoet.github.io/2019/09/04/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/"/>
    <id>https://yinyoupoet.github.io/2019/09/04/hexo博客进行百度、谷歌SEO/</id>
    <published>2019-09-04T00:42:32.000Z</published>
    <updated>2019-09-04T01:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>搭建了hexo博客并上传至github后，在百度或谷歌里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:yinyoupoet.github.io</span><br></pre></td></tr></table></figure><p>会出现如下图片↓</p><p><img alt data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/1567557893917.png" class="lozad"></p><p>这意味着百度尚未收录入我的博客，即我们无法在百度上搜到我们自己写的博客，而我们新生个人博客本身流量就低，因此我们需要进行seo优化来让搜索引擎能搜索到我们的博客，下面就介绍seo方法。</p><h2 id="纳入百度谷歌搜索引擎"><a class="markdownIt-Anchor" href="#纳入百度谷歌搜索引擎"></a> 纳入百度/谷歌搜索引擎</h2><p>先放入两个平台站点管理的网站，然后分别进入并进行相应的注册。</p><p><a href="https://ziyuan.baidu.com/linksubmit/index" target="_blank" rel="noopener">百度搜索资源平台</a></p><p><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">谷歌站点控制台</a></p><h3 id="百度"><a class="markdownIt-Anchor" href="#百度"></a> 百度</h3><p>进入百度搜索资源平台，点击链接提交并填写相应信息后，会需要验证网站</p><p><img alt="验证网站" data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/1567558548670.png" class="lozad"></p><p>在此我们使用文件验证的方式，先下载验证文件。</p><p>然后在hexo的根目录里，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>然后再在<code>hexo/public</code>目录中放入前面下载的验证文件，再部署到github上，然后点击验证即可。</p><p><strong>注意：</strong></p><ol><li>验证文件需要保存好，每次<code>hexo clean</code>后都会清空public文件夹，验证文件如果没有备份将会丢失。建议将其保存在hexo根目录下。</li><li>每次<code>hexo clean</code>后需要将验证文件重新复制到public文件夹中，以保证搜索引擎能一直收纳该网站。</li><li>不要为了图方便将验证文件放入<code>hexo/source</code>文件夹中，否则每次<code>hexo g</code>后hexo会自动加上一部分内容在验证文件中后放入public文件夹，因此访问到的验证文件被修改过了，会导致验证失败。</li></ol><h3 id="谷歌"><a class="markdownIt-Anchor" href="#谷歌"></a> 谷歌</h3><p>进入谷歌站点控制台，步骤与前面百度类似。下图中选择网址前缀，填入自己的网址后继续，使用文件验证的方式与百度的相同，在此不进行赘述。</p><p><img alt="谷歌站点控制台" data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/1567559080536.png" class="lozad"></p><h2 id="使用sitemap进行优化"><a class="markdownIt-Anchor" href="#使用sitemap进行优化"></a> 使用sitemap进行优化</h2><p>首先进入hexo根目录，并输入如下命令安装两个hexo插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save-dev</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save-dev</span><br></pre></td></tr></table></figure><p>安装好后修改你hexo的配置文件<code>_config.yml</code>，将url改成你自己的域名</p><p><img alt data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/1567559463921.png" class="lozad"></p><p>在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>可以看到在public文件夹下出现了两个文件：</p><p><code>baidusitemap.xml</code>，<code>sitemap.xml</code></p><p>这两个文件可以通过<code>https://你的域名/xxx.xml</code>访问到。</p><p>然后将博客重新部署到github上。</p><p>在百度的域名管理的<strong>链接提交</strong>子菜单中，找到如下图所示位置，将你自己服务器能访问到上述两个xml文件的地址复制进去并点击提交即可。</p><p><img alt data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/1567559551406.png" class="lozad"></p><p>对于谷歌而言，如下图所示进行设置即可。</p><p><img alt data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%99%BE%E5%BA%A6%E3%80%81%E8%B0%B7%E6%AD%8CSEO/1567559687438.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      对hexo博客进行百度、谷歌SEO，并使用sitemap工具进行优化
    
    </summary>
    
      <category term="实用工具" scheme="https://yinyoupoet.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="https://yinyoupoet.github.io/tags/hexo/"/>
    
      <category term="seo" scheme="https://yinyoupoet.github.io/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>typora + hexo博客中插入图片</title>
    <link href="https://yinyoupoet.github.io/2019/09/03/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>https://yinyoupoet.github.io/2019/09/03/hexo博客中插入图片/</id>
    <published>2019-09-03T03:52:47.000Z</published>
    <updated>2019-09-04T09:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用了hexo搭建了博客后，最大的问题便是如何使用一款markdown工具来编辑博客了，我采取的就是Typora，这工具免费简单易用没广告，而且把图片保存到本地还是很方便的，因此大家只要稍微了解点markdown语法就可以上手使用了。</p><p>关于图片和图片路径的设置，有以下教程。</p><p>事先声明，所有博客文件均保存在 <code>hexo/_posts/</code>文件夹下</p><p>首先在 <code>hexo &gt; source</code>目录下建一个文件夹叫images，用来保存博客中的图片。</p><p>然后打开Typora的 <code>文件 &gt; 偏好设置</code>，进行如下设置。</p><p><img alt data-src="/images/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/1567505538899.png" class="lozad"></p><p>这样的话所有的博客中的图片都将会保存到 <code>/source/images/该博客md文件名/图片名称</code></p><p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p><p>在typora菜单栏点击 <code>格式-&gt;图像-&gt;设置图片根目录</code>，将<code>hexo/source</code>作为其根目录即可。</p><p><strong>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确喔！</strong></p>]]></content>
    
    <summary type="html">
    
      使用hexo + typora完美实现博客编辑功能
    
    </summary>
    
      <category term="实用工具" scheme="https://yinyoupoet.github.io/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Typora" scheme="https://yinyoupoet.github.io/tags/Typora/"/>
    
      <category term="hexo" scheme="https://yinyoupoet.github.io/tags/hexo/"/>
    
      <category term="markdown" scheme="https://yinyoupoet.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>开博大吉</title>
    <link href="https://yinyoupoet.github.io/2019/09/02/%E6%96%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>https://yinyoupoet.github.io/2019/09/02/新博客/</id>
    <published>2019-09-02T04:25:00.000Z</published>
    <updated>2019-09-04T01:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正式开通github博客"><a class="markdownIt-Anchor" href="#正式开通github博客"></a> 正式开通github博客</h3><p>基于Hexo制作，使用了Butterfly主题！</p><p><img alt data-src="/images/%E6%96%B0%E5%8D%9A%E5%AE%A2/1567504904077.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      开博啦！
    
    </summary>
    
      <category term="杂" scheme="https://yinyoupoet.github.io/categories/%E6%9D%82/"/>
    
    
  </entry>
  
</feed>
