<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>设计模式总结 | yinyoupoet的博客</title><meta name="description" content="精要论述23种设计模式，并进行融会贯通。"><meta name="keywords" content="设计模式"><meta name="author" content="yinyoupoet"><meta name="copyright" content="yinyoupoet"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://yinyoupoet.github.io/2019/11/20/设计模式总结/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="设计模式总结"><meta name="twitter:description" content="精要论述23种设计模式，并进行融会贯通。"><meta name="twitter:image" content="https://yinyoupoet.github.io/images/cover&amp;top/软件体系结构.png"><meta property="og:type" content="article"><meta property="og:title" content="设计模式总结"><meta property="og:url" content="https://yinyoupoet.github.io/2019/11/20/设计模式总结/"><meta property="og:site_name" content="yinyoupoet的博客"><meta property="og:description" content="精要论述23种设计模式，并进行融会贯通。"><meta property="og:image" content="https://yinyoupoet.github.io/images/cover&amp;top/软件体系结构.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="Wireless Network Evolution - 6G &amp; AI" href="https://yinyoupoet.github.io/2019/11/05/Wireless-Network-Evolution-6G-AI/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?19446aca39e2fe294709670cbf706533";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta name="google-site-verification" content><meta name="baidu-site-verification" content><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"207CQUEWZA","apiKey":"e43d6394203388cf47dc525ade9c9210","indexName":"HexoBlog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://yinyoupoet.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text"> 引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预备知识"><span class="toc-number">2.</span> <span class="toc-text"> 预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式总体介绍"><span class="toc-number">3.</span> <span class="toc-text"> 设计模式总体介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建型模式"><span class="toc-number">4.</span> <span class="toc-text"> 创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">4.1.</span> <span class="toc-text"> 工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">4.2.</span> <span class="toc-text"> 抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建造者模式"><span class="toc-number">4.3.</span> <span class="toc-text"> 建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">4.4.</span> <span class="toc-text"> 原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">4.5.</span> <span class="toc-text"> 单例模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构型模式"><span class="toc-number">5.</span> <span class="toc-text"> 结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式"><span class="toc-number">5.1.</span> <span class="toc-text"> 适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接模式"><span class="toc-number">5.2.</span> <span class="toc-text"> 桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合模式"><span class="toc-number">5.3.</span> <span class="toc-text"> 组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰模式"><span class="toc-number">5.4.</span> <span class="toc-text"> 装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外观模式"><span class="toc-number">5.5.</span> <span class="toc-text"> 外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#享元模式"><span class="toc-number">5.6.</span> <span class="toc-text"> 享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式"><span class="toc-number">5.7.</span> <span class="toc-text"> 代理模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行为型模式"><span class="toc-number">6.</span> <span class="toc-text"> 行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#职责链模式"><span class="toc-number">6.1.</span> <span class="toc-text"> 职责链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令模式"><span class="toc-number">6.2.</span> <span class="toc-text"> 命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器模式"><span class="toc-number">6.3.</span> <span class="toc-text"> 解释器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器模式"><span class="toc-number">6.4.</span> <span class="toc-text"> 迭代器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中介者模式"><span class="toc-number">6.5.</span> <span class="toc-text"> 中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备忘录模式"><span class="toc-number">6.6.</span> <span class="toc-text"> 备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察者模式"><span class="toc-number">6.7.</span> <span class="toc-text"> 观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态模式"><span class="toc-number">6.8.</span> <span class="toc-text"> 状态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#策略模式"><span class="toc-number">6.9.</span> <span class="toc-text"> 策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法模式"><span class="toc-number">6.10.</span> <span class="toc-text"> 模板方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问者模式"><span class="toc-number">6.11.</span> <span class="toc-text"> 访问者模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">7.</span> <span class="toc-text"> 参考资料</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/cover&amp;top/软件体系结构.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">yinyoupoet的博客</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="/images/cover&top/tenor.gif" data-original="/img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 相册</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/categories/诗歌/"><i class="fa-fw fa fa-star-half-o"></i><span> 诗歌</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">设计模式总结</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-20<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-12-02</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/软件开发/">软件开发</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h2>
<p>为避免软件危机，我们引入了软件工程学，而在软件工程学中，我们常面临的一个问题就是软件维护问题。软件维护涉及面很广，细化到代码编写方面，那便对代码规范有了要求，而设计模式则是一门面向编程规范的学问。在1995年，GoF（Gang of Four，四人组/四人帮）出版了《设计模式：可复用面向对象软件的基础》一书，提出了23种设计模式，而这也成了如今非常经典的软件设计与程序编写规范。在最近几年中，笔者已学过四遍了，算不上太多心得体会，但也多少有些收获，因此将其记录下来以备查阅。本文将对设计模式进行一个精要的讲解，所涉及内容不会太详细，小白慎入。（注：本文中部分文字和图片来自网络，参考资料统一列于文章最后，侵删）</p>
<h2 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h2>
<p>要学习设计模式，首先要会一门程序设计语言，以面向对象者入手为佳，本文以java来展开。其次，要会UML的类图，关于其网上资料很多，在此不做赘述。第三点，就是一些颇为经典的软件设计原则，这里将其列出并作简单介绍：</p>
<ul>
<li>单一职责原则：一个类只干一件事——低耦合，高内聚</li>
<li>开闭原则：对扩展开放，对修改关闭</li>
<li>里氏代换原则：能接受基类的地方必能接受子类</li>
<li>依赖倒转原则：依赖于抽象而非具体类——针对抽象编程</li>
<li>接口隔离原则：用多个专门的接口取代单个统一的接口——降低耦合</li>
<li>合成复用原则：多用组合/聚合，少用继承</li>
<li>迪米特法则：若两个类不彼此直接通信，则此二者不能直接发生作用，需引入第三个类</li>
</ul>
<h2 id="设计模式总体介绍"><a class="markdownIt-Anchor" href="#设计模式总体介绍"></a> 设计模式总体介绍</h2>
<p>如下图所示，设计模式一共可分为三类模式，分别是创建型模式、结构型模式、行为型模式。</p>
<table>
<thead>
<tr>
<th>范围目的</th>
<th><strong>创建型模式</strong></th>
<th><strong>结构型模式</strong></th>
<th><strong>行为型模式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类模式</strong></td>
<td>工厂方法模式</td>
<td>（类）适配器模式</td>
<td>解释器模式  <br>模板方法模式</td>
</tr>
<tr>
<td><strong>对象模式</strong></td>
<td>抽象工厂模式  <br>建造者模式  <br>原型模式 <br> 单例模式</td>
<td>（对象）适配器模式  <br>桥接模式  <br>组合模式 <br> 装饰模式  <br>外观模式  <br>享元模式 <br> 代理模式</td>
<td>职责链模式  <br>命令模式 <br> 迭代器模式 <br> 中介者模式 <br> 备忘录模式 <br> 观察者模式  <br>状态模式  <br>策略模式  <br>访问者模式</td>
</tr>
</tbody>
</table>
<p>各类模式的关系如下图所示：</p>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120190446121.png" alt="模式关系图"></p>
<h2 id="创建型模式"><a class="markdownIt-Anchor" href="#创建型模式"></a> 创建型模式</h2>
<h3 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h3>
<blockquote>
<p><strong>Factory Method Pattern</strong>: Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120220805432.png" alt="工厂方法模式"></p>
<p>将工厂和产品都抽象化了，但是具体的生产仍是由一个具体工厂生产一个具体产品。但是需要注意的是，一个具体工厂只生产一个具体产品，即一个工厂类只负责生产一类产品对象，这虽然符合了开闭原则，但是每增加一个产品时都需要新创建一个具体产品类和一个具体工厂类。</p>
<h3 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h3>
<p>工厂模式每个具体工厂只能生产一类对象，这在需要新增加产品类时会比较麻烦，因此抽象工厂模式中一个工厂类可以创建多类对象。</p>
<blockquote>
<p><strong>Abstract Factory Pattern</strong>: Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120221832027.png" alt="抽象工厂模式"></p>
<p>譬如说某个具体工厂为海尔工厂，则其既可以生产海尔电视机，也可以生产海尔冰箱。当需要生产TCL的电视机和电冰箱时，只需添加对应的具体工厂和具体产品即可，但是如果需要添加一个新的产品，比如说海尔需要生产手机了，那么这时还得修改其对应的具体工厂，因此可以看出其对于开闭原则也不能很好地遵循。</p>
<h3 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h3>
<p>建造者模式讲究一步一步创建一个产品，创建的步骤是相同的，但是创建的产品的类型却可以不同。</p>
<blockquote>
<p><strong>Builder Pattern</strong>: Separate the construction of a complex object from its representation so that the same construction process can create different representations.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120223344579.png" alt="建造者模式"></p>
<p>客户类只需调用构造者类的<code>getResult</code>方法即可，根据具体类中每个部分的构建方式不同，<code>getResult</code>返回的内容也不同，譬如肯德基的套餐，不同的套餐都有食物和饮料，但每个套餐提供的食物和饮料的种类却是不同的。</p>
<p>增加新的具体构建者不需要修改现有代码，符合开闭原则。但是如果产品的内部变化较大，则会需要很多个具体构建者，会使得类的结构比较臃肿。</p>
<h3 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h3>
<p>原型模式说明白点就是对象的自我拷贝，返回一个和自己一模一样的对象，只需根据需求来设置深拷贝和浅拷贝即可。</p>
<blockquote>
<p><strong>Prototype Pattern</strong>: Specify the kind of objects to create using a prototypical instance, and create new objects by copying this prototype.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120224228849.png" alt="原型模式"></p>
<h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3>
<p>单例模式即为让类只能产生一个对象，无论谁来访问都只能访问到同一个对象。其原理就是将构造函数设置为私有函数，由一个公有静态接口来返回类的唯一实例。</p>
<blockquote>
<p><strong>Singleton Pattern</strong>: Ensure a class has only one instance and provide a global point of access to it.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120224444809.png" alt="单例模式"></p>
<p>单例模式分为饿汉式和懒汉式，饿汉式即在类加载时就创建了这个类的唯一实例，而懒汉式则在外部第一次获取该类的对象时才创建对象，上图所示即为懒汉式。</p>
<p>使用单例模式的思路可以设计<em>有限多例模式</em>，在此不做赘述。</p>
<h2 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式"></a> 结构型模式</h2>
<p>结构型模式讨论的是如何将类或对象结合在一起形成更大的结构，可以相应地分为类结构型模式和对象结构型模式。</p>
<h3 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h3>
<p>顾名思义，一般电脑充电器都会自带一个电源适配器，以将220V的电压适配到电脑电源所能接受的电压。适配器模式亦然，一个现有类已经实现了一些能满足客户端所要求的功能，但提供的接口不符合客户的需求，比如接口名和客户要求的接口名不同，因此这时可以设计一个适配器程序，由客户端只需调用适配器中符合客户要求的接口，而在适配器内部则代替客户端去调用那个现有类的函数。</p>
<blockquote>
<p><strong>Adapter Pattern</strong>: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120225426230.png" alt="类适配器"></p>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191120225441222.png" alt="对象适配器"></p>
<p>适配器模式使得目标类与客户类解耦，使得这个调用过程成了透明的过程，也增加了程序的可扩展性与可维护性，即便修改了目标类的实现代码，或者干脆换了一个类作为目标类，也只需要修改适配器类的内部代码即可，而不需对客户类进行任何修改。但是往往一个适配器类只能为一个客户端类服务，这也在一定程度上会使得代码比较臃肿。</p>
<h3 id="桥接模式"><a class="markdownIt-Anchor" href="#桥接模式"></a> 桥接模式</h3>
<p>桥接模式用于一个物体有两个或更多不同类型的属性的时候，用于化全连接的乘法为两两组合的加法。听起来很抽象，那就举个栗子。比如要创建一个图形，形状上有圆形、矩形、三角形，颜色上有红色、绿色、蓝色，因此如果为每一种形状都提供一个单独的颜色的版本的话，就需要9种不同的类，而如果使用桥接模式，则只需要单独定义3种图形和3种颜色，即一共6种，这在更复杂的系统中能显著减少类的数量。</p>
<p>其设计思想如下图，上面为采用全连接的思想，而下面则采用的是桥接模式的思想。</p>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124155424510.png" alt="桥接模式设计思想"></p>
<blockquote>
<p><strong>Bridge Pattern</strong>: Decouple an abstraction from its implementation so that the two can vary independently.</p>
</blockquote>
<p>桥接模式的类图如下：</p>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124160018001.png" alt="桥接模式"></p>
<p>桥接模式提高了系统的可扩展性，扩展任何一个维度都不需要修改原有的系统，符合开闭原则，且其分离了抽象接口与其具体实现，使得具体类的实现对用户透明，但是其会增加系统的理解与设计难度，且要求抽象出系统中某两个单独变化的维度，因此其使用具有一定的局限性。</p>
<h3 id="组合模式"><a class="markdownIt-Anchor" href="#组合模式"></a> 组合模式</h3>
<p>组合模式包含两类对象，分别是容器对象和叶子对象，而其目的就是可以透明地处理容器对象和叶子对象。比如对于文件和文件夹的遍历等。</p>
<blockquote>
<p><strong>Composite Pattern</strong>: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124164159949.png" alt="组合模式"></p>
<p>组合模式比较简单，就不多解释了，它分为透明组合模式和安全组合模式，透明组合模式是在抽象构建中声明所有要使用的操作，而安全组合模式中抽象构建中仅声明公有操作。</p>
<h3 id="装饰模式"><a class="markdownIt-Anchor" href="#装饰模式"></a> 装饰模式</h3>
<p>为一个类或对象增加行为，常采用的有继承和关联两种方法，然而继承的话，对现有类的扩充不能动态进行控制，而关联就不同，可以设计一个装饰类来按需求动态地扩充被嵌入对象的行为，因此装饰模式采用的是关联机制来对类进行扩充。</p>
<blockquote>
<p><strong>Decorator Pattern</strong>: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124171952767.png" alt="装饰模式"></p>
<p>需要注意的是，装饰类的接口与被装饰类的接口要保持一致，这样客户端在使用的时候才能在不修改接口的情况下调用装饰类的实现。装饰模式比使用继承更加灵活，而且也符合开闭原则、合成复用原则等。抽象模式可以分为透明模式和半透明模式，透明模式中用户完全针对抽象编程，这点作简单了解即可。</p>
<h3 id="外观模式"><a class="markdownIt-Anchor" href="#外观模式"></a> 外观模式</h3>
<p>外观模式为每一个子系统提供了一个对外通信的统一的接口（外观类），客户类只需知道这个接口即可，而具体的复杂的这个子系统的实现过程则由外观类去实现。其能显著降低系统复杂度，提高客户端使用的便捷性。</p>
<blockquote>
<p><strong>Facade Pattern</strong>: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124174332372.png" alt="外观模式"></p>
<p>用外观模式举个例子，即定义一个总开关作为外观类，其提供打开和关闭两种操作，而打开或关闭开关时，其自动打开或关闭了电灯、冰箱、电视等一系列的开关，而作为客户而言，只需打开这一个开关，子系统（外观类）就能为客户做一系列复杂的操作，而这些操作对客户而言都是透明的。但是当新增子系统时，可能需要修改外观类或客户端的源代码，这违背了开闭原则。需要注意的是，外观类的用意是为子系统提供一个集中化和简化的管理接口，因此不要在外观类中为子系统添加新的行为，那是装饰模式才干的事。</p>
<h3 id="享元模式"><a class="markdownIt-Anchor" href="#享元模式"></a> 享元模式</h3>
<p>享元模式很好理解，它的目的就是实现对象的共享。试想在开发中，加入需要经常是用到某一个字符串，比如<code>s='abc'</code>，那么就可以将这个对象丢入对象池中，每次访问时都从对象池中将其取出即可，而不用在每次使用前都new一次，这样会造成内存空间的浪费。</p>
<p>根据对象信息的性质不同，可以将信息分为两类，一个为内部状态，这个是固定在享元对象中不会变的信息，即可以共享的信息，而外部状态则是会随着环境改变而改变的信息，即不可共享的部分。</p>
<blockquote>
<p><strong>Flyweight Pattern</strong>: Use sharing to support large numbers of fine-grained objects efficiently.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124210912346.png" alt="享元模式"></p>
<p>享元模式支持大量细粒度对象的复用，能极大减小内存中对象的数量，当系统中有大量对象且这些对象消耗大量内存、且这些对象的状态大部分可以外部化时，享元模式能起到很显著的作用。</p>
<h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3>
<p>当客户端与目标对象之间不能直接通信时，往往采用代理模式，定义一个代理对象作为中介，根据实际需求为去掉一些客户不能看到的内容或者添加一些用户需要的额外服务，也包括数据加密等等。</p>
<blockquote>
<p><strong>Proxy Pattern</strong>: Provide a surrogate or placeholder for another object to control access to it.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191124211448973.png" alt="代理模式"></p>
<p>代理模式能协调客户端和目标程序之间的通信，并对其数据进行加工处理，在一定程度上降低了系统的耦合度，但是因为添加了一个代理，因此代理在进行数据处理时往往会耗费一些额外的时间，而比如远程代理，更是会带来一些额外的通信时延，且有的代理模式的实现也较为复杂。</p>
<h2 id="行为型模式"><a class="markdownIt-Anchor" href="#行为型模式"></a> 行为型模式</h2>
<p>行为型模式控制类和对象之间相互协作的任务分配和流程控制，它分为对象行为型模式和类行为型模式，而通过合成复用原则可知，对象行为型模式比类行为型模式更加灵活，因此对象行为型模式使用范围往往更广。</p>
<h3 id="职责链模式"><a class="markdownIt-Anchor" href="#职责链模式"></a> 职责链模式</h3>
<p>该模式思路为将请求发送者与接收者分离开来，即请求发送者不能直接接触到最终的接收者，所有发送者的请求都只能被送到一个职责链的开始节点，而职责链中每个节点都具有接收请求和处理请求的能力，但是每个节点能处理的请求都是有限制的，比如请假系统，每一级领导最高职能批多少天的假，超出他的审批权限则需要他将这个请求汇报给上级处理，这样一条请求链就是职责链。</p>
<blockquote>
<p><strong>Chain of Responsibility Pattern</strong>: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202201658934.png" alt="职责链模式"></p>
<p>职责链模式的使用能显著降低系统耦合度，简化对象间的连接复杂度，也使得请求的处理相对于客户而言是透明的，增加了稳定性和灵活性。但是不能保证请求一定被处理，且由于请求需要一层层传递下去，可能会对系统性能产生影响。职责链模式分为纯的和不纯的职责链模式。纯的职责链模式要求每一个职责链节点只能选择处理或者将请求传递给下一个节点，不允许在进行了部分处理后又交给下一个节点处理，且纯的职责链节点必须能处理所有可能的请求，而在不纯的职责链中，允许一个请求最终不被任何接收者处理。</p>
<h3 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h3>
<p>命令模式将请求的发送与处理完全解耦，请求发送者只需要知道发送指令的接口即可，并不需要知道是谁在什么时候执行了具体什么操作。</p>
<blockquote>
<p><strong>Command Pattern</strong>: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202202842015.png" alt="命令模式"></p>
<p>命令模式中调用者只需调用Command抽象类中的执行操作函数，而具体操作则由具体命令类来执行。它可以降低系统耦合度，也提高了系统可扩充性，易于设计组合命令，但是也可能会造成系统中具体命令类过多的情况。使用命令模式可以实现撤销功能，即在具体命令类中记录上一次的操作，从而实现撤销。</p>
<h3 id="解释器模式"><a class="markdownIt-Anchor" href="#解释器模式"></a> 解释器模式</h3>
<p>解释器模式平日里用的机会不多，它是设计了一个句子的解释器，学过编译原理的朋友们可能对词法分析、语法分析等概念还有概念，而解释器模式则设计了一个解释器去解释一个特定的句子，比如简单的四则运算，难一点的自定义代码解析等。</p>
<blockquote>
<p><strong>Interpreter Pattern</strong>: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202204243789.png" alt="解释器模式"></p>
<p>使用解释器可以很容易地改变和扩充文法，且易于增加新的解释表达式的方法，但是使用场景实在少见，执行效率较低，无特殊需求的话仅做了解即可。</p>
<h3 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h3>
<p>迭代器模式就是为一个集合定义一个遍历访问的机制，如java的List、Set等的遍历，不过这些遍历都是系统一经定义好了的，我们也可以对自己设计的集合定义遍历的方式，也可以对已有的集合定义我们所需的迭代方式。</p>
<blockquote>
<p><strong>Iterator Pattern</strong>: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202204649120.png" alt="迭代器模式"></p>
<p>迭代器模式支持对同一个集合定义不同的遍历方式，且新增便利方式或聚合类都不需要修改其他代码，符合开闭原则。但是新增聚合类则意味着要新增迭代器类，这会造成类的个数的成对增加，增加了系统复杂度。该模式使得对无需了解聚合对象的内部表示即可遍历一个聚合对象，只需一个统一的接口即可。</p>
<h3 id="中介者模式"><a class="markdownIt-Anchor" href="#中介者模式"></a> 中介者模式</h3>
<p>中介者模式的目的就是设计一个单独的中介对象来管理所有其他对象之间的相互做作用，而非让对象间自行组织和作用，它减少了对象间两两之间的引用关系，使系统成为了一个松耦合的系统。如果让对象两两间直接通信或作用，则一个对象发送变化时可能需要引起另一个对象行为的改变，这会造成系统非常复杂且难以维护。举个具体的例子，比如工厂中设备A、B、C的启动过程构成一个循环，即当启动A时A会自动启动B，而后B会自动启动C，而当启动B时B会自动启动C，而后C自动启动A，等等这样构成一个循环，本来是没问题，但是如果B设备坏了，则启动A后设备C也不会自动启动，而如果采用一个中介者，由中介者对其他设备进行启动，就没有这种问题了。</p>
<blockquote>
<p><strong>Mediator Pattern</strong>: Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202210821758.png" alt="中介者模式"></p>
<p>中介者模式简化了对象间的直接交互，但是容易造成中介者类十分复杂，难以维护。</p>
<h3 id="备忘录模式"><a class="markdownIt-Anchor" href="#备忘录模式"></a> 备忘录模式</h3>
<p>备忘录模式就相当于github上的一次提交，每提交一次都会保留一份备份。而备忘录模式也是在每一次执行备份操作的时候，保存一个对象的内部状态，并提供恢复机制，将对象还原到其之前保存的状态。</p>
<blockquote>
<p><strong>Memento Pattern</strong>: Without violating encapsulation, capture and externalize an object’s internal state so that the object can be restored to this state later.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202211231328.png" alt="备忘录模式"></p>
<p>备忘录模式提供了一种备份与恢复机制，但是如果备份较频繁，则会加大系统资源的消耗，它也可以用作实现撤销操作，且其功能相较命令模式而言要强大得多，也更易于实现。</p>
<h3 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h3>
<p>该模式又称发布-订阅模式，其目的是当一个对象（被观察者）状态发送改变时，通知其他依赖于它的对象（观察者）它的状态的改变，并视情况对观察者的状态进行调整。</p>
<blockquote>
<p><strong>Observer Pattern</strong>: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202213536454.png" alt="观察者模式"></p>
<p>该模式可以实现表示层和数据层数据的分离，当表示层数据发生变化时，这个变化可以自动传播到数据层中，如果用在注册表单中，则体现在每修改一次用户名，则可以自动异步在后台判断该用户名是否和已存用户名重名。同时一个对象可以有多个观察者，这意味着这个对象的状态发生改变后需要通知所有其他观察者，这对系统性能有点影响，且如果观察关系较为复杂，则可能存在循环观察，这点需要引起重视。</p>
<h3 id="状态模式"><a class="markdownIt-Anchor" href="#状态模式"></a> 状态模式</h3>
<p>状态模式规定一个对象在其内部状态不同的时候，同样的操作会执行不同的行为。比如同一个函数中，会判断属于什么状态再去执行相应的功能。</p>
<blockquote>
<p><strong>State Pattern</strong>: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202214255779.png" alt="状态模式"></p>
<p>从类图可以看出，每一个状态对应一个具体类，而具体操作由具体状态类来定义，这就将状态和操作从原始类中抽离了出来，这意味着新增一个具体状态时不需要修改原始代码，似乎符合开闭原则，但是它对开闭原则的支持并不太好，但是对于能够实现状态转换的类而言，每新增一个状态都需要修改类中进行状态转换的相关代码。</p>
<h3 id="策略模式"><a class="markdownIt-Anchor" href="#策略模式"></a> 策略模式</h3>
<p>策略模式指在实现某一个既定目标的时候，有多个不同的可选方法，比如排序算法，可以视情况动态选择快排、归并等算法，而不需要硬编码在原始程序中。</p>
<blockquote>
<p>​      Strategy Pattern: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202214845730.png" alt="策略模式"></p>
<p>策略模式很好地支持了开闭原则，但是它要求客户端知道所有的策略类，且策略模式会需要生成很多个策略类，可以使用享元模式在一定程度上减少策略类的个数。</p>
<h3 id="模板方法模式"><a class="markdownIt-Anchor" href="#模板方法模式"></a> 模板方法模式</h3>
<p>该方法的目的是基于继承的思路来增加代码的复用。它定义了一个抽象父类，并实现了部分公有方法，而另一些方法则仅定义了接口，留给子类去实现。</p>
<blockquote>
<p><strong>Template Method Pattern</strong>: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202215333515.png" alt="模板方法模式"></p>
<p>模板方法模式能很大程度上提高代码的复用率，但是对于每个不同的实现都需要单独定义一个子类，这会使得子类数量很多，难以维护。</p>
<h3 id="访问者模式"><a class="markdownIt-Anchor" href="#访问者模式"></a> 访问者模式</h3>
<p>该模式是针对数据或对象的访问而言，不同的用户对同一个对象或数据进行访问时往往有不同的访问权限，或会采取不同的操作手段，而访问者模式则是用来对访问的一个控制，它能使得在不修改原始代码的前提下新增数据访问或操作的方式。</p>
<blockquote>
<p><strong>Visitor Pattern</strong>: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</p>
</blockquote>
<p><img src="/images/cover&top/tenor.gif" data-original="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/image-20191202220032255.png" alt="访问者模式"></p>
<p>该模式使得新增访问操作变得很容易，所有元素相关操作都集中到了访问对象中。但是这也使得新增数据项就很困难，新增数据项需要修改所有的访问对象的代码，使得维护相当困难。</p>
<hr>
<p>以上就是23种设计模式的简单总结，若有尚不清晰之处，日后慢慢补充。</p>
<hr>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/chenssy/p/3357683.html" target="_blank" rel="noopener">设计模式总结</a></li>
<li><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">Java设计模式：23种设计模式全面解析（超级详细）</a></li>
<li><a href="https://blog.csdn.net/qq_41997479/article/details/86619024" target="_blank" rel="noopener">软件体系结构与设计模式——课程总体介绍（01-03）</a></li>
<li><a href="https://www.cnblogs.com/adamjwh/p/9070107.html" target="_blank" rel="noopener">简说设计模式——享元模式</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">yinyoupoet</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yinyoupoet.github.io/2019/11/20/设计模式总结/">https://yinyoupoet.github.io/2019/11/20/设计模式总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yinyoupoet.github.io">yinyoupoet的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/设计模式/">设计模式    </a></div><div class="post_share"><div class="social-share" data-image="/images/cover&amp;top/软件体系结构.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/images/cover&top/tenor.gif" data-original="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/images/cover&top/tenor.gif" data-original="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/05/Wireless-Network-Evolution-6G-AI/"><img class="next_cover" src="/images/cover&top/tenor.gif" data-original="/images/cover&amp;top/6G&amp;AI.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Wireless Network Evolution - 6G &amp; AI</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'smlw3k69ARv8sUTG6eFamB4N-gzGzoHsz',
  appKey:'yVLgeliGFjJizUR920FTQkj2',
  placeholder:'说点什么吧',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By yinyoupoet</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">玻璃晴朗，橘子辉煌</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#引言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 引言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#预备知识"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 预备知识</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#设计模式总体介绍"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 设计模式总体介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#创建型模式"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 创建型模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#工厂方法模式"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 工厂方法模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#抽象工厂模式"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 抽象工厂模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#建造者模式"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text"> 建造者模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#原型模式"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text"> 原型模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#单例模式"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text"> 单例模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#结构型模式"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 结构型模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#适配器模式"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text"> 适配器模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#桥接模式"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text"> 桥接模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#组合模式"><span class="toc_mobile_items-number">5.3.</span> <span class="toc_mobile_items-text"> 组合模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#装饰模式"><span class="toc_mobile_items-number">5.4.</span> <span class="toc_mobile_items-text"> 装饰模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#外观模式"><span class="toc_mobile_items-number">5.5.</span> <span class="toc_mobile_items-text"> 外观模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#享元模式"><span class="toc_mobile_items-number">5.6.</span> <span class="toc_mobile_items-text"> 享元模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#代理模式"><span class="toc_mobile_items-number">5.7.</span> <span class="toc_mobile_items-text"> 代理模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#行为型模式"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 行为型模式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#职责链模式"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 职责链模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#命令模式"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text"> 命令模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#解释器模式"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text"> 解释器模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#迭代器模式"><span class="toc_mobile_items-number">6.4.</span> <span class="toc_mobile_items-text"> 迭代器模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#中介者模式"><span class="toc_mobile_items-number">6.5.</span> <span class="toc_mobile_items-text"> 中介者模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#备忘录模式"><span class="toc_mobile_items-number">6.6.</span> <span class="toc_mobile_items-text"> 备忘录模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#观察者模式"><span class="toc_mobile_items-number">6.7.</span> <span class="toc_mobile_items-text"> 观察者模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#状态模式"><span class="toc_mobile_items-number">6.8.</span> <span class="toc_mobile_items-text"> 状态模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#策略模式"><span class="toc_mobile_items-number">6.9.</span> <span class="toc_mobile_items-text"> 策略模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#模板方法模式"><span class="toc_mobile_items-number">6.10.</span> <span class="toc_mobile_items-text"> 模板方法模式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#访问者模式"><span class="toc_mobile_items-number">6.11.</span> <span class="toc_mobile_items-text"> 访问者模式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#参考资料"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 参考资料</span></a></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/algolia.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body></html>